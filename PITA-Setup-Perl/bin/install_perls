#!/usr/bin/perl

require 5;
use Cwd;
use Data::Dumper;
use Getopt::Long;

my $pwd = getcwd;
my $instmain = "/opt/perl";

my ($help, @versions);

GetOptions(
	"h|help"    => \$help,
	"version=s" => \@versions,
	"tardir=s"  => \$pwd,
	"instdir=s" => \$instmain,
) or print_help(1);
print_help() if $help;

opendir(Dir,$pwd) or do {
	print "Can't open current directory? $pwd: $!\n";
	print_help(1);
};
my @tars = grep { /^perl.*tar\.gz$/ } readdir(Dir);
closedir(Dir);

unless (-d $instmain) {
	mkdir $instmain;
	unless (-d $instmain) {
		die "Can't create $instmain - please do so manually or use --instdir.\n";
	}
}

foreach my $tarball (@tars) {
	my ($base,$ver) = $tarball =~ /^(perl-?(5(?:\.?_?\d+)+))\.tar\.gz$/ or next;

	if (@versions) {
		next unless grep { $_ eq $ver } @versions;
	}

	if (0) {

	if (-d "$instmain/$base") {
		print "Not installing Perl $ver - directory $instmain/$base exists.\n";
		print "Please remove this directory and run the installer again.\n\n";
		next;
	}
	elsif (-d "$pwd/$base") {
		print "Removing old install directory for Perl $ver...\n";
		chdir $pwd;
		system("rm -rf $base");
		check_system_call($?,$!,"rm");
		if (-d "$pwd/$base") {
			print "Can't remove old install directory, skipping Perl $ver\n\n";
			next;
		}
	}

	print "Unpacking Perl $base...\n";
	chdir $pwd;
	system("gunzip -c $tarball | tar xf -");
	check_system_call($?,$!,"gunzip | tar") && next;
	chdir "$pwd/$base";

	print "Configuring Perl $ver...\n";
	my $develflag = '';
	if ($ver =~ /^5\.9/) {
		$develflag = "-Dusedevel";
	}
	system("./Configure -des -Dprefix='$instmain/$base' -Dinstallusrbinperl=n $develflag > $pwd/config-$ver.txt 2>&1");
	check_system_call($?,$!,"./Configure") && next;

	print "Making Perl $ver...\n";
	system("make > $pwd/make-$ver.txt 2>&1");
	check_system_call($?,$!,"make") && next;

	print "Testing Perl $ver...\n";
	system("make check > $pwd/check-$ver.txt 2>&1");
	check_system_call($?,$!,"make check") && next;

	print "Installing Perl $ver...\n";
	system("make install > $pwd/install-$ver.txt 2>&1");
	check_system_call($?,$!,"make install") && next;

	} # if 0

	print "Writing CPAN file for Perl $ver...\n";
	my $cpanver = $ver;
	$cpanver =~ s/_//;
	if ($cpanver =~ /5.00[01234]/) {
		write_cpan($ver,"$instmain/$base/lib/CPAN","$instmain/.cpan-$cpanver");
	}
	else {
		write_cpan($ver,"$instmain/$base/lib/$cpanver/CPAN","$instmain/.cpan-$cpanver");
	}

	print "Removing build directory of Perl $ver...\n";
	chdir $pwd;
	system("rm -rf $base");
	check_system_call($?,$!,"rm");

	print "Perl $ver installed.\n\n";
}

exit(0);

sub check_system_call {
	my ($stat,$bang,$cmd) = @_;
	if ($stat == -1) {
		print "$cmd: failed to execute: $bang\n";
		return 1;
	}
	elsif ($stat & 127) {
		printf "$cmd: child died with signal %d, %s coredump\n", ($stat & 127),  ($stat & 128) ? 'with' : 'without';
		return 1;
	}
	elsif ($stat >> 8) {
		printf "$cmd: child exited with value %d\n", $stat >> 8;
		return 1;
	}

	return;
}

sub print_help {
	print <<HELP;
Usage: $0 [OPTION]...
Install a set of Perl distribution tarballs.

Options:
    -h            This help output
    --instdir=""  Location to install Perls into (default: /opt/perl)
    --tardir=""   Location of perl tarballs (default: current directory)
    --version=""  A specific version to install; can be used multiple times
HELP
	exit(1) if $_[0];
	exit(0);
}

sub write_cpan {
	my $ver = shift;
	my $dir = shift;
	my $build = shift;

	unless (-d $dir) {
		mkdir $dir or do {
			print "Can't make directory $dir: $!\n";
			return;
		};
	}

	unless (-d $build) {
		mkdir $build or print "Can't make directory $build - but this is not fatal.\n";
	}

	eval { use CPAN::Config; };
	$CPAN::Config = {} unless !$@ && defined($CPAN::Config);

	my $real_config = {
		build_cache 		=> 100,
		build_dir   		=> "$build/build",
		cache_metadata 		=> 1,
		cpan_home 		=> $build,
		histfile		=> "$build/histfile",
		histsize	 	=> 100,
		inactivity_timeout	=> 0,
		index_expire		=> 1,
		inhibit_startup_message => 0,
		keep_source_where	=> "$build/sources",
		prefer_installer        => 'EUMM',
		prerequisites_policy    => 'follow',
		scan_cache              => 'atstart',
		show_upload_date        => 1,
		term_is_latin           => 1,
		urllist			=> [ 'http://10.0.0.2/CPAN/', 'http://search.cpan.org/CPAN/' ],
	};

	foreach my $binary qw( 
		bzip2 curl ftp getcwd gpg gzip lynx make
 		ncftpget pager shell tar unzip wget ) {

		if ($CPAN::Config->{$binary}) {
			if (-x $CPAN::Config->{$binary}) {
				$real_config->{$binary} = $CPAN::Config->{$binary};
				next;
			}
		}

		if ($ENV{uc($binary)} && -x $ENV{uc($binary)}) {
			$real_config->{$binary} = $ENV{uc($binary)};
			next;
		}

		if ($binary eq 'shell') {
			foreach my $shell qw( bash tcsh zsh sh cmd ) {
				my $bin = File::Which::which($shell);
				if ($bin && -x $bin) {
					$real_config->{'shell'} = $bin;
					next;
				}
			}
		}
		elsif ($binary eq 'pager') {
			foreach my $pager qw( less more ) {
				my $bin = File::Which::which($pager);
				if ($bin && -x $bin) {
					$real_config->{'pager'} = $bin;
					next;
				}
			}
		}
		elsif ($binary eq 'getcwd') {
			foreach my $pager qw( cwd pwd ) {
				my $bin = File::Which::which($binary);
				if ($bin && -x $bin) {
					$real_config->{$binary} = $bin;
					next;
				}
			}
		}
		else {
			my $bin = File::Which::which($binary);
			if ($bin && -x $bin) {
				$real_config->{$binary} = $bin;
				next;
			}
		}

		$real_config->{'binary'} = '';
	}

	$real_config->{'make_install_make_command'} = $real_config->{'make'};
	$real_config->{'mbuild_install_build_command'} = './Build';

	# proxies	
	$real_config->{'ftp_proxy'} = '';
	$real_config->{'http_proxy'} = '';
	$real_config->{'no_proxy'} = '';

	# TODO find better values for these ( -j3, for example )
	$real_config->{'make_arg'} = '';
	$real_config->{'make_install_arg'} = '';
	$real_config->{'makepl_arg'} = '';
	$real_config->{'mbuild_arg'} = '';
	$real_config->{'mbuild_install_arg'} = '';
	$real_config->{'mbuildpl_arg'} = '';

	my ($sub) = $ver =~ /^5.0*(\d+)[_\.]/;
	if ($sub && $sub >= 6) {
		$real_config->{'dontload_hash'} = {};
	}

	open CPANConf, ">$dir/Config.pm" or do {
		print "Can't write $file: $!\n";
		return;
	};

	print CPANConf Data::Dumper->Dump([$real_config],[q($CPAN::Config)]);
	close CPANConf;
	return;
}

=pod

TODO

* Detect if a binary actually works, in addition to "finding" it
  (idea by Yaakov Sloman)

=cut

# File::Which is inlined here to prevent a CPAN dependency.

package File::Which;

use strict;

require Exporter;

@File::Which::ISA       = qw(Exporter);

# PETEK custom patch: We're not exporting.
@File::Which::EXPORT    = qw();
@File::Which::EXPORT_OK = qw(which where);

$File::Which::VERSION = '0.05';

use File::Spec;

my $Is_VMS    = ($^O eq 'VMS');
my $Is_MacOS  = ($^O eq 'MacOS');
my $Is_DOSish = (($^O eq 'MSWin32') or
                ($^O eq 'dos')     or
                ($^O eq 'os2'));

# For Win32 systems, stores the extensions used for
# executable files
# For others, the empty string is used
# because 'perl' . '' eq 'perl' => easier
my @path_ext = ('');
if ($Is_DOSish) {
    if ($ENV{PATHEXT} and $Is_DOSish) {    # WinNT. PATHEXT might be set on Cygwin, but not used.
        push @path_ext, split ';', $ENV{PATHEXT};
    }
    else {
        push @path_ext, qw(.com .exe .bat); # Win9X or other: doesn't have PATHEXT, so needs hardcoded.
    }
}
elsif ($Is_VMS) { 
    push @path_ext, qw(.exe .com);
}

sub which {
    my ($exec) = @_;

    return undef unless $exec;

    my $all = wantarray;
    my @results = ();
    
    # check for aliases first
    if ($Is_VMS) {
        my $symbol = `SHOW SYMBOL $exec`;
        chomp($symbol);
        if (!$?) {
            return $symbol unless $all;
            push @results, $symbol;
        }
    }
    if ($Is_MacOS) {
        my @aliases = split /\,/, $ENV{Aliases};
        foreach my $alias (@aliases) {
            # This has not been tested!!
            # PPT which says MPW-Perl cannot resolve `Alias $alias`,
            # let's just hope it's fixed
            if (lc($alias) eq lc($exec)) {
                chomp(my $file = `Alias $alias`);
                last unless $file;  # if it failed, just go on the normal way
                return $file unless $all;
                push @results, $file;
                # we can stop this loop as if it finds more aliases matching,
                # it'll just be the same result anyway
                last;
            }
        }
    }

    my @path = File::Spec->path();
    unshift @path, File::Spec->curdir if $Is_DOSish or $Is_VMS or $Is_MacOS;

    for my $base (map { File::Spec->catfile($_, $exec) } @path) {
       for my $ext (@path_ext) {
            my $file = $base.$ext;
# print STDERR "$file\n";

            if ((-x $file or    # executable, normal case
                 ($Is_MacOS ||  # MacOS doesn't mark as executable so we check -e
                  ($Is_DOSish and grep { $file =~ /$_$/i } @path_ext[1..$#path_ext])
                                # DOSish systems don't pass -x on non-exe/bat/com files.
                                # so we check -e. However, we don't want to pass -e on files
                                # that aren't in PATHEXT, like README.
                 and -e _)
                ) and !-d _)
            {                   # and finally, we don't want dirs to pass (as they are -x)

# print STDERR "-x: ", -x $file, " -e: ", -e _, " -d: ", -d _, "\n";

                    return $file unless $all;
                    push @results, $file;       # Make list to return later
            }
        }
    }
    
    if($all) {
        return @results;
    } else {
        return undef;
    }
}

sub where {
    my @res = which($_[0]); # force wantarray
    return @res;
}

1;
