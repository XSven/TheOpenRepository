=head1 NAME

Marpa::Semantics - How Marpa Evaluates Parses

=head1 DESCRIPTION

This document describes
the way in which Marpa applies semantics to parse trees
and produces a value from them.
The semantics described in this document are
shared by Marpa's 
Single Parse Evaluator and
Multi-parse Evaluator.

To those who have used traditional
methods to evaluate parse tress,
Marpa's semantics will sound familiar.
A parse is seen as a tree.
Nodes on the tree are evaluated recursively, bottom-up.
Once the values of all its child nodes are known,
an parent node is ready to be evaluated.

Nodes in the parse tree are associated either with tokens
or with rules.
For nodes associated with rules,
node evaluation can be specified with a per-rule action.
The per-rule action resolves to a Perl closure which is
called when that node is ready to be evaluated.
The arguments to a node's Perl closure are a
per-parse variable followed by,
in lexical order,
the values of its child nodes.
The value returned by the Perl closure becomes the
value of the node.

For nodes associated with tokens,
the token value is the value of the node.
Tokens can be assigned a B<token value> at lexing time.
When a token value is not specified at lex time,
the token value defaults to a Perl C<undef>.

A node is nulled if it derives the empty string.
This can happen if the grammar contains rules with
no symbols on the right hand side.
If a node associated with a rule is nulled,
it is evaluated in a special way.

Nulled nodes can have other nulled nodes as children.
With a parse, a set of nulled nodes can form a subtree.
In evaluating a nulled subtree, all the nodes are ignored
except the topmost one.
For the topmost nulled node of a subtree,
the value of the node is the null value of the
symbol which produces the subtree.
This will be the same as the
left hand side symbol
for the rule associated with the topmost node
of the nulled subtree.

A null value can be specified on a per-symbol basis.
If a symbol does have a per-symbol null value,
the symbol's null value is the
default null value for the grammar.
If the grammar has no default null value,
the symbol's null value defaults to a Perl C<undef>.

If no closure was specified to implement the semantics for an
interior node's rule,
the value of the interior node is
a Perl C<undef>.
The value of a parse is the value of the top node 
of the parse tree.

=head1 TIMES

=head2 Evaluator Setup

Before any processing of the actual parse.
Null values are computed at this point.
No context and
Context-aware static methods available at this point.

=head2 Bocage Setup

Bocage has been set up.
Multi-parse evaluator calls ranking actions at this point.
Context-aware static methods available at this point.

=head2 Parse Setup

=head2 Parse Tree Traversal

Parse tree traversal is when Marpa traverses the parse tree,
evaluating each of its nodes.

=head2 Node Evaluation

Node evaluation time occurs for each parse tree node
during parse tree traversal.
Rule actions are called at this point.
Node evaluation time is parse tree traversal,
from the point of view of an individual node of the parse tree.

=head1 RESOLVING ACTIONS

=head2 The Bang Convention

=head1 NULL SUBTREES

A "null value" is the value used for a symbol when it is nulled in a parse.
By default, the null value is a Perl undefined.
The default null value can be reset with the 
L<C<default_null_value> named argument|Marpa::Grammar/default_null_value>.

A null subtree may contain of many nodes, but all of them
must always be nulled.
B<The value of a null subtree is the null value of the
left hand symbol for its topmost node.>
This section describes in detail how a parse is evaluated,
focusing on what happens when nulled symbols are involved.

=head2 Example

Suppose a grammar has these rules

=for Marpa::Display
name: Null Value Example
perltidy: '-dcsc -sil=0'

    sub default_action {
        shift;
        my $v_count = scalar @_;
        return q{}   if $v_count <= 0;
        return $_[0] if $v_count == 1;
        return '(' . ( join q{;}, ( map { $_ // 'undef' } @_ ) ) . ')';
    } ## end sub default_action

    my $grammar = Marpa::Grammar->new(
        {   start   => 'S',
            actions => 'main',
            rules   => [
                [ 'S', [qw/L R/] ],
                [ 'L', [qw/A B X/] ],
                [ 'L', [] ],
                [ 'R', [qw/A B Y/] ],
                [ 'R', [] ],
                [ 'A', [] ],
                [ 'B', [] ],
                [ 'X', [] ],
                [ 'Y', [] ],
            ],
            default_action => 'default_action',
            symbols        => {
                L => { null_value => 'null L' },
                R => { null_value => 'null R' },
                A => { null_value => 'null A' },
                B => { null_value => 'null B' },
                X => { null_value => 'null X', terminal => 1 },
                Y => { null_value => 'null Y', terminal => 1 },
            },
        }
    );

=for Marpa::Display::End

Let the input be a single token,
with the token name "C<X>".

    Show tokens() call.

    Show output of above.

=head1 SEQUENCES

The arguments to closures for sequence rules behave similarly
to the arguments for ordinary, non-sequence, rules.
The value of the node's child symbols
immediately follow
the per-parse variable,
in lexical order.

The only difference (but it is a big one)
is that in an ordinary rule, the right hand side
is fixed in length.
In a sequence rule,
the application does not know in advance the number of right hand side symbols.

Sequence sentences work best where the semantics really is that of a sequence
of semantically equivalent items.
Where that's not the case, writing that section of the grammar as
ordinary non-sequence rules should be thought of as preferable to
an over-complicated sequence semantics.

By default, if a sequence rule has separators,
the separators are thrown away before
the semantics are applied.
They do not appear in the C<@_> array.

If the value of the C<keep> rule property
is a Perl true, separators are kept.
When separators are kept in the C<@_> array,
it is up to
the Perl closure implementing the semantics to figure out
which of its arguments 
are separators and which are sequence items.

=head2 Zero-length Sequences

One "corner case" should be noted in the semantics of sequences.
In Marpa, in most cases,
a rule is always zero length or it is never zero length.
Coordinating null value semantics with the semantics for
rules is usually not an issue.

Sequence rules with a
C<min> rule property of 0 are an exception.
They can be any length, including zero length.
And when they are zero length, they use the standard semantics for zero length,
or nulled, rules.

When a rule is not zero length,
its value is the value returned by the semantic action for its rule,
or C<undef> if no semantic action is defined.
When a rule is zero length,
its value will be the null value of the left hand
side symbol of the rule.

It's up to the
application to make sure that null value of the left hand side
of the sequence rules "makes sense"
as the value of a zero length sequence.
Where the correct semantics do not fall out of a "natural" approach
to the grammar,
a special symbol may need to be
dedicated to serving as the left hand side
symbol for the sequence, so that it can carry the
correct semantics.

The rules for nodes in nulled subtrees apply with equal force
to nodes for sequence rules.
In a nulled subtree, the only node whose semantics matters
is the root node of that subtree.
If a zero-length sequence is in a nulled subtree,
and that zero-length sequence
is not the root node of that subtree,
its semantics will be completely ignored.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2010 Jeffrey Kegler, all rights reserved.
Marpa is free software under the Perl license.
For details see the LICENSE file in the Marpa distribution.

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
