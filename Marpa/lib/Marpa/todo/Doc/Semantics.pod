=head1 NAME

Marpa::Semantics - How Marpa Evaluates Parses

=head1 DESCRIPTION

This document describes
the way in which Marpa applies semantics to parse trees
and produces a value from them.
It describes Marpa's "original semantics",
the semantics shared by
its two evaluators (the Single Parse Evaluator and
the Multi-parse Evaluator).

=head2 Times

=head3 Evaluator Setup

=head3 Parse Setup

=head3 Parse Tree Traversal

Parse tree traversal is when Marpa traverses the parse tree,
evaluating each of its nodes.

=head3 Node Evaluation

Node evaluation time occurs for each parse tree node
during parse tree traversal.
Node evaluation time is parse tree traversal,
from the point of view of an individual node of the parse tree.

=head2 Summary of Marpa's Semantics

Marpa's semantics are traditional.
A parse is seen as a tree.
Nodes on the tree are evaluated recursively, bottom-up.
When the values of all child nodes have been computed,
an interior node is ready to be valued.
At this point,
a Perl closure is called based on the rule for that interior
node.

The arguments to the interior node's Perl closure are a
per-instance variable followed by,
in lexical order,
the values of its child nodes.
Marpa's parse tree have two kinds of leaf node:
tokens and nulled symbols.
Tokens can be assigned a B<token value> at lexing time.
All nullable symbols can
have a B<null value> assigned to
them when the grammar is created.

B<Interior nodes> are nodes which are not leaf nodes.
Every interior node corresponds to a rule.
Interior nodes implement their semantics with Perl closures which are
specified on a per-rule basis.

The value of a token leaf node is the token value.
If a token value was not specified for a token at lex time,
the token value defaults to a Perl C<undef>.

The value of a nulled-symbol leaf node is the nulled value
of the symbol.
If a nullable symbol was not assigned a nulled value,
the null value defaults to a Perl C<undef>.

The value returned by the interior node's Perl closure becomes
the value of the interior node.
If no closure was specified to implement the semantics for an
interior node's rule,
the value of the interior node is
a Perl C<undef>.
The value of a parse is the value of the top node 
of the parse tree.

=head2 Resolving Actions into Closures

=head3 The Bang Convention

=head2 Null Values

A "null value" is the value used for a symbol when it is nulled in a parse.
By default, the null value is a Perl undefined.
The default null action can be reset with the 
L<C<default_null_action> named argument|Marpa::Grammar/default_null_action>.

Each symbol can have its own null symbol value.
The null value for any symbol is calculated using that symbol's null action.
The B<null action> for a symbol is the action
specified for the empty rule with that symbol on its left hand side.

Even though it is expressed as a rule property,
the null symbol action is B<not> a rule action.
It's a property of the symbol, and applies whenever the symbol is nulled,
even when the symbol's empty rule is not involved.

For example,
the following rule descriptor specified
that, whenever the symbol C<A> is nulled,
its value should be a string that reports it missing.

    { lhs=>'A', action => sub {return 'A is missing'}, }

Null symbol actions are evaluated differently from rule actions.
Null symbol actions are run at evaluator creation time and the value of the result
at that point
becomes fixed as the null symbol value.
This is not the case with rule actions.
During the creation of the evaluator object,
rule actions are B<compiled into closures>.
During parse evaluation,
whenever a node for that rule needs its value recalculated,
the compiled rule closure is run.
A compiled rule closure
can produce a different value every time it runs.

Null actions are treated differently
because they always have no child values,
so that a fixed value is almost always what is wanted.
If you want to calculate a symbol's null value at node evaluation time,
the null symbol action can return a reference to a closure.
Any rules with that nullable symbol in their right hand side
can then be set up to run that closure.

=head3 Evaluating Null Subtrees

A null subtree may contain of many nodes, but all of them
must always be nulled.
B<The value of a null subtree is the null value of the
left hand symbol for its topmost node.>
This section describes in detail how a parse is evaluated,
focusing on what happens when nulled symbols are involved.

=head3 Example

Suppose a grammar has these rules

=for Marpa::Display
name: Null Value Example
perltidy: '-dcsc -sil=0'

    sub default_action {
        shift;
        my $v_count = scalar @_;
        return q{}   if $v_count <= 0;
        return $_[0] if $v_count == 1;
        return '(' . ( join q{;}, ( map { $_ // 'undef' } @_ ) ) . ')';
    } ## end sub default_action

    sub null_A { return 'null A' }
    sub null_B { return 'null B' }
    sub null_R { return 'null R' }
    sub null_L { return 'null L' }
    sub null_X { return 'null X' }
    sub null_Y { return 'null Y' }

    my $grammar = Marpa::Grammar->new(
        {   start   => 'S',
            actions => 'main',
            rules   => [
                [ 'S', [qw/L R/] ],
                [ 'L', [qw/A B X/] ],
                [ 'L', [] ],
                [ 'R', [qw/A B Y/] ],
                [ 'R', [] ],
                [ 'A', [] ],
                [ 'B', [] ],
                [ 'X', [] ],
                [ 'Y', [] ],
            ],
            default_action => 'default_action',
            symbols        => {
                L => { null_action => 'null_L' },
                R => { null_action => 'null_R' },
                A => { null_action => 'null_A' },
                B => { null_action => 'null_B' },
                X => { null_action => 'null_X', terminal => 1 },
                Y => { null_action => 'null_Y', terminal => 1 },
            },
        }
    );

=for Marpa::Display::End

In the above MDL, the Perl 5 regex "C</Z/>" occurs on the rhs of Rule 6.
Where a regex is on the rhs of a rule, MDL internally creates a terminal symbol
to match that regex in the input text.
In this example, the MDL internal terminal symbol that
matches input text using the regex
C</Z/> will be called C<Z>.

If the input text is the Perl 5 string "C<Z>",
the derivation is as follows:

    S -> A Y      (Rule 0)
      -> A "Z"    (Y produces "Z", by Rule 6)
      -> B C "Z"  (A produces B C, by Rule 2)
      -> B "Z"    (C produces the empty string, by Rule 4)
      -> "Z"      (B produces the empty string, by Rule 3)

The parse tree can be described as follows:

    Node 0 (root): S (2 children, nodes 1 and 4)
        Node 1: A (2 children, nodes 2 and 3)
	    Node 2: B (matches empty string)
	    Node 3: C (matches empty string)
	Node 4: Y (1 child, node 5)
	    Node 5: "Z" (terminal node)

Here's a table showing, for each node, its lhs symbol,
the sentence it derives, and
its value.

                        Symbol      Sentence     Value
                                    Derived

    Node 0:                S         "Z"         "A is missing, but Zorro is here"
        Node 1:            A         empty       "A is missing"
	    Node 2:        B         empty       No value
	    Node 3:        C         empty       No value
	Node 4:            Y         "Z"         "Zorro was here"
	    Node 5:        -         "Z"         "Z"

In this derivation,
nodes 1, 2 and 3 derive the empty sentence.
None of them are the start node so that none of them count.

Nodes 0, 4 and 5 all derive the same non-empty sentence, C<Z>,
so they all count.
Node 0 is the start node, so it would have counted in any case.

Since node 5 is a terminal node, it's value comes from the lexer.
Where the lexing is done with a Perl 5 regex,
the value will be the Perl 5 string that the regex matched.
In this case it's the string "C<Z>".

Node 4 is not nulled,
so it is evaluated normally, using the rule it represents.
That is rule 6.
The action for rule 6 returns "C<Zorro was here>", so that
is the value of node 4.
Node 4 has a child node, node 5, but rule 6's action pays no
attention to child values.
The action for each rule is free to use or not use child values.

Nodes 1, 2 and 3 don't count and will all remain unevaluated.
The only rule left to be evaluated
is node 0, the start node.
It is not nulled, so
its value is calculated using the action for the rule it
represents (rule 0).

Rule 0's action uses the values of its child nodes.
There are two child nodes and their values are
elements 0 and 1 in the C<@_> array of the action.
The child value represented by the symbol C<Y>,
C<< $_[1] >>, comes from node 4.
From the table above, we can see that that value was
"C<Zorro was here>".

The first child value is represented by the symbol C<A>,
which is nulled.
For nulled symbols, we must use the null symbol value.
Null symbol values for each symbol can be explicitly set
by specifying an rule action for an empty rule with that symbol
as its lhs.
For symbol C<A>,
this was done in Rule 1.
Rule 1's action evaluates to the Perl 5 string
"C<A is missing>".

Even though rule 1's action plays a role in calculating the value of this parse,
rule 1 is not actually used in the derivation.
No node in the derivation represents rule 1.
Rule 1's action is used because it is the null symbol action for
the symbol C<A>.

Now that we have both child values, we can use rule 0's action
to calculate the value of node 0.
That value is "C<A is missing, but Zorro was here>",
This becomes the value of C<S>, rule 0's left hand side symbol and
the start symbol of the grammar.
A parse has the value of its start symbol,
so "C<A is missing, but Zorro was here>" is also
the value of the parse.

=head1 Sequences 

The arguments to closures for sequence rules behave similarly
to the arguments for ordinary, non-sequence, rules.
The value of the node's child symbols
immediately follow
the per-instance variable,
in lexical order.

The only difference (but it is a big one)
is that in an ordinary rule, the right hand side
is fixed in length.
In a sequence rule,
the application does not know in advance the number of right hand side symbols.

Sequence sentences work best where the semantics really is that of a sequence
of semantically equivalent items.
Where that's not the case, writing that section of the grammar as
ordinary non-sequence rules should be thought of as preferable to
an over-complicated sequence semantics.

By default, if a sequence rule has separators,
the separators are thrown away before
the semantics are applied.
They do not appear in the C<@_> array.

If the value of the C<keep> rule property
is a Perl true, separators are kept.
When separators are kept in the C<@_> array,
it is up to
the Perl closure implementing the semantics to figure out
which of its arguments 
are separators and which are sequence items.

=head2 Actions for Zero Length Sequences

One "corner case" should be noted in the semantics of sequences.
Actions for nulled symbols and actions for non-null rules are
dealt with differently.
Actions for nulled symbols are only once,
at the beginning of evaluation, even when there are
multiple parses, and they do not get any arguments.
The per-parse variable does not yet exist when
the actions for nulled symbols are run.

Actions for non-null rules are run again each time 
a new node for that rule needs a value computed.
They always have a per-parse variable, as well
as arguments for the value of each of their child nodes.

An action which is specified for a sequence with a C<min>
property of zero must be prepared to be run either as
the action for a nulled symbol, or as the action for
a non-null rule.
Alternatively, a null action can be set up for the symbol
on the left hand side of the sequence.
In the zero-length case,
the lhs symbol's null action will be used.
In non-zero length cases
the action for the sequence rule will be used.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2010 Jeffrey Kegler, all rights reserved.
Marpa is free software under the Perl license.
For details see the LICENSE file in the Marpa distribution.

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
