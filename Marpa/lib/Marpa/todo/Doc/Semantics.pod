=head1 NAME

Marpa::Semantics - How Marpa Evaluates Parses

=head1 DESCRIPTION

This document describes
the way in which Marpa applies semantics to parse trees
and produces a value from them.
The semantics described in this document are
shared by Marpa's 
Single Parse Evaluator and
Multi-parse Evaluator.

=head2 Times

=head3 Evaluator Setup

Before any processing of the actual parse.
Null values are computed at this point.
No context and
Context-aware static methods available at this point.

=head3 Bocage Setup

Bocage has been set up.
Multi-parse evaluator calls ranking actions at this point.
Context-aware static methods available at this point.

=head3 Parse Setup

=head3 Parse Tree Traversal

Parse tree traversal is when Marpa traverses the parse tree,
evaluating each of its nodes.

=head3 Node Evaluation

Node evaluation time occurs for each parse tree node
during parse tree traversal.
Rule actions are called at this point.
Node evaluation time is parse tree traversal,
from the point of view of an individual node of the parse tree.

=head2 Summary of Marpa's Semantics

Marpa's semantics are traditional.
A parse is seen as a tree.
Nodes on the tree are evaluated recursively, bottom-up.
Once the values of all its child nodes are known,
an parent node is ready to be evaluated.

Nodes in the parse tree are associated either with tokens
or with rules.
For nodes associated with rules,
node evaluation can be specified with a per-rule action.
The per-rule action resolves to a Perl closure which is
called when that node is ready to be evaluated.
The arguments to a node's Perl closure are a
per-parse variable followed by,
in lexical order,
the values of its child nodes.
The value returned by the Perl closure becomes the
value of the node.

For nodes associated with tokens,
the token value is the value of the node.
Tokens can be assigned a B<token value> at lexing time.
When a token value is not specified at lex time,
the token value defaults to a Perl C<undef>.

A node is nulled if it derives the empty string.
This can happen if the grammar contains rules with
no symbols on the right hand side.
If a node associated with a rule is nulled,
it is evaluated in a special way.

Nulled nodes can have other nulled nodes as children.
With a parse, a set of nulled nodes can form a subtree.
In evaluating a nulled subtree, all the nodes are ignored
except the topmost one.
For the topmost nulled node of a subtree,
the value of the node is the null value of the
symbol which produces the subtree.
This will be the same as the
left hand side symbol
for the rule associated with the topmost node
of the nulled subtree.

The null value of a symbol is computed at evaluation setup
time from the null action for that symbol.
A null action can be specified on a per-symbol basis.
If a null action is specified, it is resolved to a Perl
closure.
At evaluation setup time,
the null action Perl closure is called to calculate
the symbol's B<null value>.
If a symbol does have a per-symbol null action,
it the default null action is used to calculate
that symbol's B<null value>.
If there is no default null action,
the symbol's null value defaults to a Perl C<undef>.

If no closure was specified to implement the semantics for an
interior node's rule,
the value of the interior node is
a Perl C<undef>.
The value of a parse is the value of the top node 
of the parse tree.

=head2 Resolving Actions into Closures

=head3 The Bang Convention

=head2 Null Values

A "null value" is the value used for a symbol when it is nulled in a parse.
By default, the null value is a Perl undefined.
The default null action can be reset with the 
L<C<default_null_action> named argument|Marpa::Grammar/default_null_action>.

Each symbol can have its own null symbol value.
The null value for any symbol is calculated using that symbol's null action.
The B<null action> for a symbol is the action
specified for the empty rule with that symbol on its left hand side.

Even though it is expressed as a rule property,
the null symbol action is B<not> a rule action.
It's a property of the symbol, and applies whenever the symbol is nulled,
even when the symbol's empty rule is not involved.

For example,
the following rule descriptor specified
that, whenever the symbol C<A> is nulled,
its value should be a string that reports it missing.

    { lhs=>'A', action => sub {return 'A is missing'}, }

Null symbol actions are evaluated differently from rule actions.
Null symbol actions are run at evaluator creation time and the value of the result
at that point
becomes fixed as the null symbol value.
This is not the case with rule actions.
During the creation of the evaluator object,
rule actions are B<compiled into closures>.
During parse evaluation,
whenever a node for that rule needs its value recalculated,
the compiled rule closure is run.
A compiled rule closure
can produce a different value every time it runs.

Null actions are treated differently
because they always have no child values,
so that a fixed value is almost always what is wanted.
If you want to calculate a symbol's null value at node evaluation time,
the null symbol action can return a reference to a closure.
Any rules with that nullable symbol in their right hand side
can then be set up to run that closure.

=head3 Evaluating Null Subtrees

A null subtree may contain of many nodes, but all of them
must always be nulled.
B<The value of a null subtree is the null value of the
left hand symbol for its topmost node.>
This section describes in detail how a parse is evaluated,
focusing on what happens when nulled symbols are involved.

=head3 Example

Suppose a grammar has these rules

=for Marpa::Display
name: Null Value Example
perltidy: '-dcsc -sil=0'

    sub default_action {
        shift;
        my $v_count = scalar @_;
        return q{}   if $v_count <= 0;
        return $_[0] if $v_count == 1;
        return '(' . ( join q{;}, ( map { $_ // 'undef' } @_ ) ) . ')';
    } ## end sub default_action

    sub null_A { return 'null A' }
    sub null_B { return 'null B' }
    sub null_R { return 'null R' }
    sub null_L { return 'null L' }
    sub null_X { return 'null X' }
    sub null_Y { return 'null Y' }

    my $grammar = Marpa::Grammar->new(
        {   start   => 'S',
            actions => 'main',
            rules   => [
                [ 'S', [qw/L R/] ],
                [ 'L', [qw/A B X/] ],
                [ 'L', [] ],
                [ 'R', [qw/A B Y/] ],
                [ 'R', [] ],
                [ 'A', [] ],
                [ 'B', [] ],
                [ 'X', [] ],
                [ 'Y', [] ],
            ],
            default_action => 'default_action',
            symbols        => {
                L => { null_action => 'null_L' },
                R => { null_action => 'null_R' },
                A => { null_action => 'null_A' },
                B => { null_action => 'null_B' },
                X => { null_action => 'null_X', terminal => 1 },
                Y => { null_action => 'null_Y', terminal => 1 },
            },
        }
    );

=for Marpa::Display::End

Let the input be a single token,
with the token name "C<X>".

    Show tokens() call.

    Show output of above.

=head1 Sequences 

The arguments to closures for sequence rules behave similarly
to the arguments for ordinary, non-sequence, rules.
The value of the node's child symbols
immediately follow
the per-parse variable,
in lexical order.

The only difference (but it is a big one)
is that in an ordinary rule, the right hand side
is fixed in length.
In a sequence rule,
the application does not know in advance the number of right hand side symbols.

Sequence sentences work best where the semantics really is that of a sequence
of semantically equivalent items.
Where that's not the case, writing that section of the grammar as
ordinary non-sequence rules should be thought of as preferable to
an over-complicated sequence semantics.

By default, if a sequence rule has separators,
the separators are thrown away before
the semantics are applied.
They do not appear in the C<@_> array.

If the value of the C<keep> rule property
is a Perl true, separators are kept.
When separators are kept in the C<@_> array,
it is up to
the Perl closure implementing the semantics to figure out
which of its arguments 
are separators and which are sequence items.

=head2 Actions for Zero Length Sequences

One "corner case" should be noted in the semantics of sequences.
Actions for nulled symbols and actions for non-null rules are
dealt with differently.
Actions for nulled symbols are only once,
at the beginning of evaluation, even when there are
multiple parses, and they do not get any arguments.
The per-parse variable does not yet exist when
the actions for nulled symbols are run.

Actions for non-null rules are run again each time 
a new node for that rule needs a value computed.
They always have a per-parse variable, as well
as arguments for the value of each of their child nodes.

An action which is specified for a sequence with a C<min>
property of zero must be prepared to be run either as
the action for a nulled symbol, or as the action for
a non-null rule.
Alternatively, a null action can be set up for the symbol
on the left hand side of the sequence.
In the zero-length case,
the lhs symbol's null action will be used.
In non-zero length cases
the action for the sequence rule will be used.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2010 Jeffrey Kegler, all rights reserved.
Marpa is free software under the Perl license.
For details see the LICENSE file in the Marpa distribution.

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
