=head1 NAME

Marpa::API::Recognizer - Marpa Recognizer Objects

=head1 DESCRIPTION

The L<C<Marpa::Recognizer::new> constructor|/new>
creates a recognizer object from a
precomputed Marpa grammar object.
The L<C<Marpa::Recognizer::tokens>|/tokens>
method recognizes tokens.

Pedantically, recognition and evaluation are distinct things.
Recognition is determining whether there is a parse.
Evaluation is determining the value of a parse.
But recognition in its pedantic sense is of little
practical interest.
L<Marpa::Recognizer> incorporates many evaluation functions.

In particular,
L<Marpa::Recognizer> has a built-in "Single Parse Evaluator",
which works on unambiguous grammars.
The Single Parse Evaluator also works for
ambiguous parses if the grammar is not
infinitely ambiguous.
The Single Parse Evaluator only return one parse.
For ambiguous grammars,
The Single Parse Evaluator returns one of the parses,
selected arbitrarily.
The Single Parse Evaluator 
is a good choice when there is only one parse,
or for an application that only needs one parse,
and is not fussy about which one.

=head2 Location

In traditional parsing, location is position in a token stream.
This is often the case in Marpa, but Marpa allows
other input models.
This document will assume
that Marpa is using the traditional, token-stream,
model of the input,
unless it states otherwise.

The B<current parse location>, or B<current earleme>
is the location at which the next input is expected.
Intuitively, the current earleme can be thought of as
the recognizer's current position.
Marpa will have completed its tables (or Earley sets)
out to the current earleme,
so the current earleme is often referred to as the 
B<last completed earleme>.

At times, this document will also refer to the
B<furthest earleme>.
The B<furthest earleme>.
is only significant when input models other than
the token-stream model are used.

The reason for the term I<earleme>,
and Marpa's ability to support other input models,
are discussed
L<in their own section|//"EARLEMES">.

=head1 CONSTRUCTOR

=head2 new

The C<new> method's arguments are references to hashes of named
arguments.
In the key/value pairs of these hashes, the key is the argument name,
and the hash value is the value of the argument.
The C<new> method either returns a new parse object or throws an exception.

The C<grammar> named argument must be specified and its value must be
a precomputed Marpa grammar object.
Details of the named arguments are L<below|/"NAMED ARGUMENTS">.

=head1 MUTATORS

=head2 end_input

Indicate that input is finished.
The C<end_input> method takes no arguments.
Calling C<end_input> is not necessary in the recognizer's
C<default> mode.

After a successful call to 
the C<end_input> method,
the current earleme will be the same as the furthest earleme.
Any further calls to C<tokens> will cause an
exception to be thrown.

The C<end_input> method returns a Perl true value on success.
On failure, it throws an exception.
The C<end_input> method can only usefully be called once
per recognizer, but the method is idempotent.
Subsequent calls to the C<end_input> method
have no effect and return a Perl true.

=head2 set

The C<set> method's arguments are references to hashes of named
arguments.
It can be used to set or change named arguments after the recognizer
has been created.
Details of the named arguments are L<below|/"NAMED ARGUMENTS">.

=head2 strip

The C<strip> method removes recognizer data that is
not needed once input is finished.
This greatly reduces the amount of memory the recognizer uses.
An attempt to strip a recognizer before input is finished
will cause an exception.

=head2 tokens

The C<tokens> method takes two arguments.
The first is a reference to an array of token descriptors.
The second, optional, argument is a B<reference> to an index into that array,
used when the call is B<interactive>.

Tokens descriptors are references to arrays.
The elements of the token descriptor array are, in order,
the token name, the token value, the token length
and the token offset.
The token name must be the name of a symbol which is valid as a terminal
in the grammar.
Only the token name is required --
the other elements may omitted.

The token value can be any Perl scalar.
If omitted, the token value is a Perl C<undef>.

The token length and the token offset arguments are
not used in the traditional, token-stream, model of the input.
Their use is described in L<the discussion of alternative input
models, below|/"EARLEMES">.

If the second, array index, argument is given,
the call to C<tokens> is B<interactive>.
Interactive calls to the C<tokens> are only allowed in C<stream> mode.

After adding the tokens to the recognizer,
the C<earleme> method determines whether the recognizer is active or exhausted.
If the recognizer is still active,
the C<earleme> method moves the current earleme forward by one,
and the C<earleme> method returns 1.
If the recognizer is exhausted, the current earleme stays where it is,
and the C<earleme> method returns 0.
The C<earleme> method throws an exception on failure.
Any attempt to add more input to an exhausted recognizer will fail.

Each token argument is a reference to a three element array.
The first element is a "cookie" for the token's symbol,
as returned by the C<Parse::Marpa::Grammar::get_symbol> method
or the C<get_symbol> method of a porcelain interface.
The second element is the token's value in the parse,
and may be any value legal in Perl 5, including undefined.
The third is the token's length in earlemes.

While the recognizer is active, 
an earleme remains the current earleme during only one call of the C<earleme> method.
All tokens starting at that earleme must be added in that call.
The first time that the C<earleme> method is called in a recognizer,
the current earleme is at earleme 0.

Once a recognizer is exhausted, the current earleme never moves
and no more input can be added.
It is possible for a call to B<earleme>
with no arguments
to exhaust the recognizer.
This happens if
C<earleme> is called
with zero arguments when the current earleme reaches 
the furthest earleme.

=head2 value

The value mutator implements
L<the Single Parse Evaluator|/"SINGLE PARSE EVALUATOR">.
It is described in L<its own section|/"SINGLE PARSE EVALUATOR">.

=head1 ACCESSOR

=head2 check_terminal

=head1 TRACE ACCESSORS

=head2 show_earley_sets

=head1 NAMED ARGUMENTS

=head2 grammar

=head2 mode

    modes are default, stream

=head2 too_many_earley_items

=head2 trace_earley_sets

=head2 trace_file_handle

=head2 trace_terminals

=head2 warnings

    Value Inherited from Grammar?
    I don't think so.

=head1 SINGLE PARSE EVALUATOR

=head2 end

=head2 closure

=head2 trace_actions

=head2 trace_values

=head1 INPUT MODELS

The standard model of input is a token stream, and the rest of this
document assumes the token-stream model.
Marpa allows other input models.
Readers not interested in alternatives to the token-stream model
may skip this section.

    From the earleme description:

    Each argument represents a token which starts at the B<current earleme>.
    Because ambiguous lexing is allowed.
    more than one token may start at each earleme,
    in which case, there will be one argument per token.
    Because tokens can span earlemes,
    no tokens may start at an earleme
    in which case the call to C<earleme> will have zero arguments.

Marpa allows ambiguous tokens.
Several Marpa tokens can start at a single parsing location.
Marpa tokens can be of various lengths.
Marpa tokens can even overlap.

For most parsers, position is location in a token stream.
To deal with variable-length and overlapping tokens,
Marpa needs a more flexible idea of location.
Marpa's idea of position is location in an B<earleme> stream.
B<Earlemes> are named after Jay Earley, the inventor of the first algorithm
in Marpa's lineage.

While scanning, Marpa keeps track of the B<current earleme>.
Earlemes in an earleme start at earleme 0 and increase numerically.
The earleme immediately following earleme 0 is earleme 1,
the earleme immediately following earleme 1 is earleme 2,
and so on.
The earleme immediately following earleme I<N> is always earleme I<N+1>.

B<Distance> in the earleme stream are what you'd expect.
The distance between earleme I<X> and earleme I<Y> is
the absolute value of the difference between I<X> and I<Y>,
I<|X-Y|>.
The distance from earleme 3 to earleme 6,
for example, is 3 earlemes.

Whenever a token is given to Marpa to be scanned,
it starts at the current earleme.
In addition to the type and value of the token,
Marpa must be told token's B<length> in earlemes.
The length of a Marpa token must be greater than zero.
This earleme length will become
the distance from the start of the
token to the end of the token.

The start of the token is put at the current earleme.
If the length of the token is I<L>,
and the number of the current earleme is I<C>,
the end of the token will be at the earleme number I<C+L>.

=head2 The One-Character-Per-Earleme Model

Many different models of the relationship between tokens and earlemes
are possible, but two are particularly important.
One is the one-token-per-earleme model.
The other is the one-character-per-earleme model.

Every character will be treated as being exactly one
earleme in length.
Any tokens which are more than one several character in length,
will span earlemes.

When a one-character-per-earleme model of input is used,
there will be many earlemes at which no tokens start.
In a standard implementation
of a grammar for a language which allows
comments,
for example,
no tokens will start at
any earlemes which corresponds to character locations inside
a comment.

=head2 Other Models

Marpa is not restricted to the one-character-per-earleme model.
Most parser generators treat location as position in a token stream.
In Marpa, this correspoind to a
one-token-per-earleme model.

If you use the C<earleme> method, you can structure your input in almost any way you like.
There are only four restrictions:

=over 4

=item 1

Scanning always starts at earleme 0.

=item 2

Earleme I<N> is always scanned immediately before earleme I<N+1>.
In other words, the earlemes are scanned one by one in increasing numerical order.

=item 3

When an earleme is scanned, all tokens starting at that earleme must be
added.
It is perfectly acceptable for there to be no tokens
starting at a given earleme.
However, once earleme I<N> is scanned,
it is no longer possible to add a token starting at any of the earlemes
from 0 to I<N>.

=item 4

With every token, a length in earlemes must be given,
and this length cannot be zero or negative.

=back

Marpa parsing can remain active even if
no token is found at the current earleme.
In the one-character-per-earleme model,
the current earleme might fall in the middle of a
previously recognized token
and parsing will remain active at least until the end of that
token is reached.
In the one-character-per-earleme model,
stretches where no token either starts or ends
can be many earlemes in length.

=head2 Earlemes

A recognizer is created with
the current earleme
set at earleme 0.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2010 Jeffrey Kegler, all rights reserved.
Marpa is free software under the Perl license.
For details see the LICENSE file in the Marpa distribution.

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
