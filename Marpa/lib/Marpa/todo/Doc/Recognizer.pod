=head1 NAME

Marpa::Recognizer - Marpa Recognizers

=head1 DESCRIPTION

L<Marpa::Recognizer> is the package which creates a recognizer from a
precomputed Marpa Grammar and recognizes tokens with it.
Technically, recognition is finding the parse,
and evaluation is determining its value, but
L<Marpa::Recognizer> has a built-in "speed evaluator"
which works on unambiguous grammars.
The speed evaluator also works for
ambiguous parses if the grammar is not
infinitely ambiguous.
For ambiguous parses, 
L<Marpa::Recognizer>'s
returns one parse, picked at random.
This is fine when there is only one parse,
or when the application only requires one parse,
and is not fussy about which one.

=head1 CONSTRUCTOR METHOD

=head2 new

The C<new> method's one, required, argument is a hash reference of named
arguments.
The C<new> method either returns a new parse object or throws an exception.
The C<grammar> named argument must be specified.
If the C<grammar> named argument is specified, 
its value must be a grammar object with rules defined.

=head1 MUTATOR METHODS

=head2 end_input

Used to indicate the end of input.
Tells the recognizer that
no new tokens will be added,
or, in other words,
that no tokens will start at
or after the current earleme.
The C<end_input> method takes no arguments.

The C<end_input> method
does not change the location of the furthest earleme.
After a successful call to 
the C<end_input> method,
the current earleme will be positioned at the furthest earleme.
Since positioning the current earleme at the furthest
earleme leaves the recognizer exhausted,
any further calls to C<text> will return 0,
and any further calls to C<earleme> will throw an
exception.

The C<end_input> method returns a Perl true value on success.
On failure, it throws an exception.
The C<end_input> method can only usefully be called once
per recognizer, but the method is idempotent.
Subsequent calls to the C<end_input> method
will have no effect and will return a Perl true.

=head2 set

=head2 strip

=head2 tokens

The C<earleme> method takes zero or more arguments.
Each argument represents a token which starts at the B<current earleme>.
Because ambiguous lexing is allowed.
more than one token may start at each earleme,
in which case, there will be one argument per token.
Because tokens can span earlemes,
no tokens may start at an earleme
in which case the call to C<earleme> will have zero arguments.

After adding the tokens to the recognizer,
the C<earleme> method determines whether the recognizer is active or exhausted.
If the recognizer is still active,
the C<earleme> method moves the current earleme forward by one,
and the C<earleme> method returns 1.
If the recognizer is exhausted, the current earleme stays where it is,
and the C<earleme> method returns 0.
The C<earleme> method throws an exception on failure.
Any attempt to add more input to an exhausted recognizer will fail.

Each token argument is a reference to a three element array.
The first element is a "cookie" for the token's symbol,
as returned by the C<Parse::Marpa::Grammar::get_symbol> method
or the C<get_symbol> method of a porcelain interface.
The second element is the token's value in the parse,
and may be any value legal in Perl 5, including undefined.
The third is the token's length in earlemes.

While the recognizer is active, 
an earleme remains the current earleme during only one call of the C<earleme> method.
All tokens starting at that earleme must be added in that call.
The first time that the C<earleme> method is called in a recognizer,
the current earleme is at earleme 0.

Once a recognizer is exhausted, the current earleme never moves
and no more input can be added.
It is possible for a call to B<earleme>
with no arguments
to exhaust the recognizer.
This happens if
C<earleme> is called
with zero arguments when the current earleme reaches 
the furthest earleme.

C<earleme> is the low-level token input method.
Unlike C<text>, the C<earleme> method assumes no particular model of the input.
It is up to the user to define the relationship between
tokens and earlemes.

=head1 ACCESSOR METHODS

=head2 check_terminal

=head2 furthest

=head2 status

=head2 find_parse

=head2 show_earley_sets

=head1 NAMED ARGUMENTS

=head2 grammar

=head2 mode

    modes are default, stream

=head2 too_many_earley_items

=head2 trace_earley_sets

=head2 trace_file_handle

=head2 trace_terminals

=head2 warnings

    Value Inherited from Grammar?
    I don't think so.

=head1 AFTER HERE FROM PREVIOUS DOC

=head2 Tokens and Earlemes

Marpa allows ambiguous tokens.
Several Marpa tokens can start at a single parsing location.
Marpa tokens can be of various lengths.
Marpa tokens can even overlap.

For most parsers, position is location in a token stream.
To deal with variable-length and overlapping tokens,
Marpa needs a more flexible idea of location.
Marpa's idea of position is location in an B<earleme> stream.
B<Earlemes> are named after Jay Earley, the inventor of the first algorithm
in Marpa's lineage.

While scanning, Marpa keeps track of the B<current earleme>.
Earlemes in an earleme start at earleme 0 and increase numerically.
The earleme immediately following earleme 0 is earleme 1,
the earleme immediately following earleme 1 is earleme 2,
and so on.
The earleme immediately following earleme I<N> is always earleme I<N+1>.

B<Distance> in the earleme stream are what you'd expect.
The distance between earleme I<X> and earleme I<Y> is
the absolute value of the difference between I<X> and I<Y>,
I<|X-Y|>.
The distance from earleme 3 to earleme 6,
for example, is 3 earlemes.

Whenever a token is given to Marpa to be scanned,
it starts at the current earleme.
In addition to the type and value of the token,
Marpa must be told token's B<length> in earlemes.
The length of a Marpa token must be greater than zero.
This earleme length will become
the distance from the start of the
token to the end of the token.

The start of the token is put at the current earleme.
If the length of the token is I<L>,
and the number of the current earleme is I<C>,
the end of the token will be at the earleme number I<C+L>.

=head3 The One-Character-Per-Earleme Model

Many different models of the relationship between tokens and earlemes
are possible, but two are particularly important.
One is the one-token-per-earleme model.
The other is the one-character-per-earleme model.
If you do your lexing with the C<text> method,
you will use a
one-character-per-earleme model.

Using the C<text> method, Marpa receives the input as the series
of strings and string reference.
provided in the one or more calls to the C<text> method.
The B<raw input> can be thought of the concatenation of these
strings,
even though the strings are not physically concatenated.
When the C<text> method is used,
character position in this raw input will 
correspond exactly one-to-one with the earleme position.

Every character will be treated as being exactly one
earleme in length.
Any tokens which are more than one several character in length,
will span earlemes.

It is common, when a one-character-per-earleme model of input is used,
for there to be many earlemes at which no tokens start.
For example,
in a standard implementation
of a grammar for a language which allows
comments,
no tokens will start at
any earlemes which corresponds to character locations inside
a comment.

=head3 Other Models

Marpa is not restricted to the one-character-per-earleme model.
Most parser generators treat location as position in a token stream.
In Marpa, this correspoind to a
one-token-per-earleme model.

If you use the C<earleme> method, you can structure your input in almost any way you like.
There are only four restrictions:

=over 4

=item 1

Scanning always starts at earleme 0.

=item 2

Earleme I<N> is always scanned immediately before earleme I<N+1>.
In other words, the earlemes are scanned one by one in increasing numerical order.

=item 3

When an earleme is scanned, all tokens starting at that earleme must be
added.
It is perfectly acceptable for there to be no tokens
starting at a given earleme.
However, once earleme I<N> is scanned,
it is no longer possible to add a token starting at any of the earlemes
from 0 to I<N>.

=item 4

With every token, a length in earlemes must be given,
and this length cannot be zero or negative.

=back

=head2 Exhaustion

At the start of parsing,
the B<furthest earleme> is earleme 0.
When a token is recognized, its end earleme is determined by
adding the token length to the current earleme.
If the new token's end earleme is after the furthest earleme,
the furthest earleme is set at the new token's end earleme.

If, after scanning all the tokens at an earleme,
the current earleme
has reached the furthest earleme,
no more successful parses are possible.
At this point, the recognizer is said to
be B<exhausted>.
A recognizer is B<active>
if and only if it is not exhausted.

Parsing is said to be exhausted,
when the recognizer is exhausted.
Parsing is said to be active,
when the recognizer is active.

Exhausted parsing does not mean failed parsing.
In particular,
parsing is often exhausted at the point of a successful parse.
An exhausted recognizer
may also contain successful parses
both prior to the current earleme.

Conversely, active parsing does not mean successful parsing.
A recognizer remains active as long as some potential input
I<might> produce a successful parse.
This does not mean that it ever will.

Marpa parsing can remain active even if
no token is found at the current earleme.
In the one-character-per-earleme model,
the current earleme might fall in the middle of a
previously recognized token
and parsing will remain active at least until the end of that
token is reached.
In the one-character-per-earleme model,
stretches where no token either starts or ends
can be many earlemes in length.

=head2 Earlemes

A recognizer is created with
the current earleme
set at earleme 0.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2010 Jeffrey Kegler, all rights reserved.
Marpa is free software under the Perl license.
For details see the LICENSE file in the Marpa distribution.

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
