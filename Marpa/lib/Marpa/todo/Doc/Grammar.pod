=head1 NAME

Marpa::Grammar - Marpa Grammar Objects

=head1 DESCRIPTION

Marpa's grammar objects are
created with the C<new> method.
Rules may be specified and
other named arguments used
when the grammar is created, or later using
the C<set> method.

The C<precompute> method
adds data structures that the recognizer will need
to the grammar object.
After precomputation
a grammar is "frozen".
The C<set> method and some tracing accessors may be called after 
precomputation, but
no new rules may added and
most other named arguments are no longer valid.

=head2 Symbol Names

Any valid Perl string not ending in a right square bracket is an acceptable
symbol name.
Marpa reserves
for its internal use those
symbol names which end in right square brackets

=head2 Terminals

B<Terminals> are symbols which are acceptable as token symbols.
In other words, terminals are symbols which are valid in the input.
Marpa allows terminals to appear on the left
hand side of rules.
Most parser generators do not allow terminals
on the left hand side of a rule.

If a Marpa grammar has no empty rules,
by default all valid symbols are also valid as terminals.
A grammar has the option of explicitly marking its terminals.
Terminals can be explicitly marked using
the
L<C<terminals> named argument|//"terminals">,
or the 
L<C<terminal> property|//"The terminal Symbol Property">,
of the
L<C<symbols> named argument|//"symbols">.

If a Marpa grammar has no empty rules and no
terminals are explicitly marked,
all symbols are valid as terminals.
If a Marpa grammar has no empty rules,
but some terminals are explicitly marked,
only explicitly marked terminals are
valid as terminals.

If a Marpa grammar has empty rules,
only explicitly marked terminals are
valid as terminals.
When a Marpa grammar has empty rules
but there are no explicitly marked terminals,
an exception is thrown at precomputation time.

Precomputation can be more efficient for grammars
which explicitly mark their terminals.
Marpa checks that all token names are valid terminals,
and explicitly marking terminals allows the recognizer
to check the input more strictly.
Severely restricting the symbols which are valid as terminals
is traditional.

=head1 CONSTRUCTOR METHOD

=head2 new

=for Marpa::Display
name: Engine Synopsis Unambiguous Parse
partial: 1
normalize-whitespace: 1

    my $grammar = Marpa::Grammar->new(
        {   start   => 'Expression',
            actions => 'My_Actions',
            default_action => 'first_arg',
            rules   => [
                { lhs => 'Expression', rhs => [qw/Term/] },
                { lhs => 'Term', rhs => [qw/Factor/] },
                { lhs => 'Factor', rhs => [qw/Number/] },
                { lhs => 'Term', rhs => [qw/Term Add Term/], action => 'do_add' },
                {   lhs    => 'Factor',
                    rhs    => [qw/Factor Multiply Factor/],
                    action => 'do_multiply'
                },
            ],
        }
    );

=for Marpa::Display::End

C<Parse::Marpa::Grammar::new> 
returns a new Marpa grammar object or throws an exception.
The arguments to
C<Parse::Marpa::Grammar::new> are
references to hashes of named arguments.
In the key/value pairs of these hashes,
the name of the argument is the hash key,
and the value of the argument is the hash value.
The available named arguments are described
L<below|//"Named Arguments">.

=head1 MUTATORS

=head2 precompute

=for Marpa::Display
name: Engine Synopsis Unambiguous Parse
partial: 1
normalize-whitespace: 1

    $grammar->precompute();

=for Marpa::Display::End

The C<precompute> method precomputes a Marpa grammar.
Precomputation compiles data structures that the recognizer will need.
It returns the grammar object or throws an exception.

=head2 set

The arguments to the
C<set> method are
references to hashes of named arguments.
The available named arguments are described
L<below|//"Named Arguments">.
C<set> either returns true or throws an exception.

=head1 ACCESSORS

=head2 check_terminal

Returns a Perl true when its argument is the name of a terminal symbol.
Otherwise, returns a Perl false.
Not usually needed, but in unusual sitations a lexer may find this
the easiest way to determine if a symbol is a terminal.

=head1 TRACE ACCESSORS

All the trace methods are accessors.

=head2 show_NFA

=for Marpa::Display
name: show_NFA Synopsis
perltidy: '-dcsc -sil=0'

    print $grammar->show_NFA()
        or Carp::croak "print failed: $OS_ERROR";

=for Marpa::Display::End

Returns a multi-line string listing the states of the NFA
with the LR(0) items and transitions for each.
Not useful before the grammar is precomputed.
Not really helpful for debugging grammars
and requires very deep knowledge of Marpa internals.

=head2 show_QDFA

=for Marpa::Display
name: show_QDFA Synopsis
perltidy: '-dcsc -sil=0'

    print $grammar->show_QDFA()
        or Carp::croak "print failed: $OS_ERROR";

=for Marpa::Display::End

Returns a multi-line string listing the states of the QDFA
with the LR(0) items, NFA states, and transitions for each.
Not useful before the grammar is precomputed.
Very useful in debugging, but requires knowledge of Marpa internals.

=head2 show_problems

=for Marpa::Display
name: show_problems Synopsis
perltidy: '-dcsc -sil=0'

    print $grammar->show_problems()
        or Carp::croak "print failed: $OS_ERROR";

=for Marpa::Display::End

Returns a string describing the problems a grammar had in the precomputation phase.
For many precomputation problems, Marpa
does not immediately throw an exception.
This is because there are often several problems with a grammar.
Throwing an exception on the first problem would
force the user to fix them one at a time -- very tedious.
If there were no problems, returns a string saying so.

This method is not useful before precomputation.
The recognizer will
throw an exception
if the user attempts
to create a parse from
a grammar with problems.
The string returned by C<show_problems> will be part of that exception's
error message.

=head2 show_rules

=for Marpa::Display
name: show_rules Synopsis
perltidy: '-dcsc -sil=0'

    print $grammar->show_rules()
        or Carp::croak "print failed: $OS_ERROR";

=for Marpa::Display::End

Returns a string listing the rules.
Marpa does extensive rewriting of its grammar,
and the rules are shown in their rewritten form.
C<show_rules> is often useful in debugging grammars
and much of the information requires no knowledge of
the Marpa internals to interpret.

Each rule is shown with B<comments> which
indicate either rule properties
or internal settings.
Comments for the rules indicate
whether they
were nullable, unproductive, inaccessible, empty,
or had a non-zero priority.

When Marpa rewrites a rule, it often marks
the original rule "do not use".
Inaccessible and unproductive rules are also
marked "do not use".
C<show_rules> shows a "do not use" marking
as an "C<!used>" comment for that rule.

Many of the comments show
rule settings relevant to the
semantics.
For example,
the "<discard_sep"> comment indicates that the rule
discards separators
(something which is only
relevant for sequence rules).
For more details,
see
L<the implementation document|Marpa::Implementation>.

=head2 show_symbols

=for Marpa::Display
name: show_symbols Synopsis
perltidy: '-dcsc -sil=0'

    print $grammar->show_symbols()
        or Carp::croak "print failed: $OS_ERROR";

=for Marpa::Display::End

Returns a string listing the symbols, along with comments
indicating whether they were
terminal, nulling, nullable, unproductive or inaccessible.
Also shown is a list of rules with that symbol on the left hand side,
and a list of rules which have that symbol anywhere on the right hand side.
Often useful and much of the information requires no knowledge of
the Marpa internals to interpret.

=head1 NAMED ARGUMENTS

=head2 action_object

The C<action_object> named argument expresses semantics.
Its standard use is as a class name to be used
in resolving action names to Perl closures.
If a C<new> constructor is defined in C<action_object>,
that constructor is used to create the per-parse variables.
Details are given in
L<the document on semantics|Marpa::Semantics>.

=head2 actions

=for Marpa::Display
name: Engine Synopsis Unambiguous Parse
partial: 1
normalize-whitespace: 1

            actions => 'My_Actions',

=for Marpa::Display::End

The C<actions> named argument expresses semantics.
Its standard use is specify
a Perl package in which Marpa should use when resolving
action names to Perl closures.
If both an 
C<actions> named argument and an
C<action_object> named argument are specified,
the 
C<actions> named argument takes precedence.
The C<actions> package is treated only as a package,
and not as a class.
Any C<new> constructor in the C<actions> package is ignored.
Details are given in
L<the document on semantics|Marpa::Semantics>.

=head2 infinite_action

Takes as its value a string specifying what Marpa
should do if it discovers its grammar is infinitely
ambigious.
The value must be one of
"C<fatal>",
"C<warn>" or
"C<quiet>".
A grammar is B<infinitely ambiguous> if there
is some input for which it produces an
an endless number of parses.

If the value is "C<fatal>",
Marpa throws an exception when it encounters
an infinitely ambiguous grammar.
This is the default.
It will usually be what the user wants.
In most cases,
an infinitely ambiguous grammar is simply a mistake.

"C<quiet>" indicates the user wants to allow
infinitely ambiguous grammars.
"C<warn>" indicates the user wants to allow
infinitely ambiguous grammars, but
wants a warning message to be printed
to the trace file handle.

The setting of the C<infinite_action> property and
the choice of evaluators are independent of each other.
The Single Parse Evaluator will detect attempts to
use it with an infinitely ambiguous grammar
and throw an exception at evaluator setup time.

=head2 default_action

=for Marpa::Display
name: Engine Synopsis Unambiguous Parse
partial: 1
normalize-whitespace: 1

            default_action => 'first_arg',

=for Marpa::Display::End

The C<default_action> named argument expresses semantics.
Its standard use is to specify the semantic action
for rules when no per-rule semantic action is
defined.
Details are given in
L<the document on semantics|Marpa::Semantics>.

=head2 default_null_action

The C<default_null_action> named argument expresses semantics.
Its standard use is to specify the action used
to calculate the null value for
those symbols
which do not have a per-symbol null action defined.
Details are given in
L<the document on semantics|Marpa::Semantics>.

=head2 inaccessible_ok

The value must be a reference to an array of symbol names.
By default, Marpa warns if a symbol is inaccessible, but
the warning is suppressed for any symbol named in the array.
Setting the C<inaccessible_ok> named argument
after grammar precomputation is useless,
and itself results in a warning.

Inaccessible symbols sometimes indicate errors in the grammar
design.
But a user may have plans for these symbols,
may wish to keep them as notes,
or may simply wish to deal with them later.

=head2 rules

=for Marpa::Display
name: Engine Synopsis Unambiguous Parse
partial: 1
normalize-whitespace: 1

    rules => [
        { lhs => 'Expression', rhs => [qw/Term/] },
        { lhs => 'Term',       rhs => [qw/Factor/] },
        { lhs => 'Factor',     rhs => [qw/Number/] },
        { lhs => 'Term', rhs => [qw/Term Add Term/], action => 'do_add' },
        {   lhs    => 'Factor',
            rhs    => [qw/Factor Multiply Factor/],
            action => 'do_multiply'
        },
    ],

=for Marpa::Display::End

The value of the
C<rules> named argument is a reference to an array of
B<rule descriptors>.
The C<rules> named argument may be specified multiple times,
adding new rules to the grammar each time.
New rules may be added until the grammar is precomputed.
The format of rule descriptors is L<explained
below|//"RULE DESCRIPTORS">.

=head2 start

The value of the C<start> named argument must be a symbol name.
It will be used as the start symbol for the grammar.
The C<start> named argument is required.

=for Marpa::Display
name: Engine Synopsis Unambiguous Parse
partial: 1
normalize-whitespace: 1

    start => 'Expression',

=for Marpa::Display::End

=head2 strip

The value is a Boolean.
If true, Marpa "strips" the grammar during precomputation
of all data structures that are
not needed for further processing.
This saves space and time.
This is the default behavior.

If C<strip> is set to false, data in the grammar object
is not stripped.
It is kept available
for tracing and debugging.

=head2 symbols

=for Marpa::Display
name: Null Value Example
partial: 1
normalize-whitespace: 1

    symbols        => {
        L => { null_action => 'null_L' },
        R => { null_action => 'null_R' },
        A => { null_action => 'null_A' },
        B => { null_action => 'null_B' },
        X => { null_action => 'null_X', terminal => 1 },
        Y => { null_action => 'null_Y', terminal => 1 },
    },

=for Marpa::Display::End

The value of the C<symbols> named
arguments must a a reference to a hash.
In the key/values pairs of this hash,
the keys are symbol names
and the values are symbol descriptors.
Symbol descriptors are described L<below|SYMBOL DESCRIPTORS>.

The value of C<symbols> named argument is a hash
while the value of the C<rules> named argument.
This could be seen as non-orthogonal, but
there's a reason.
Symbols are uniquely idenitifed by name
and that name makes a convenient hash key.
Rules have no
convenient and obvious candidate for a hash key,
so it makes more sense to define them in arrays.

=head2 terminals

The value of the C<terminals> named argument
must be a reference to an array of symbol names.
Specifying symbols in a
a C<terminals> named argument
is one way of
explicitly marking them as terminals.
Explicity marking of terminals is not necessary
when unless a grammar has empty rules.
For more, see
L<the discussion of terminals above|//Terminals>.

=head2 trace_file_handle

The value is a file handle.
Trace output and warning messages
go to the trace file handle.
By default the trace file handle is C<STDERR>.

=head2 trace_rules

Traces rules as they are added to the grammar.
Useful, but you may prefer the C<show_rules()> method.
Doesn't require knowledge of Marpa internals.

A C<trace_rules> setting becomes effective
within the named argument hash which sets it.
A trace message warns the user if he turns
on rule tracing when
rules have already been added.

=head2 unproductive_ok

The value must be a reference to an array of symbol names.
By default, Marpa warns if a symbol is unproductive, but
the warning is suppressed for any symbol named in the array.
Setting the C<unproductive_ok> named argument
after grammar precomputation is useless,
and itself results in a warning.

Unproductive symbols sometimes indicate errors in the grammar
design.
But a user may have plans for these symbols,
may wish to keep them as notes,
or may simply wish to deal with them later.

=head2 warnings

The value is a boolean.
Warnings are written to the trace file handle.
By default, warnings are on.
Usually, an application will want to leave them on.
If warnings are turned off,
turning them back on
after grammar precomputation is useless,
and itself results in a warning.

=head1 RULE DESCRIPTORS

=head2 Long Form

The long form descriptor of a rule is a hash
of B<rule properties>.
The property names are the hash keys,
and the property values are the hash values.

=head2 Sequence Rules

It is very common in a grammar for one symbol to derive a
sequence of other symbols.
Marpa allows sequence rules as a shorthand for this.

A rule is a sequence rule if the C<min> rule property is defined.
C<min> can be 0 or 1, and indicates the minimum length of the
sequence.
As of this writing, the maximum length is always infinite.

    { lhs => 'sequence', rhs => [qw(sequence_item)], min => 0 }

A C<min> of zero means a sequence of 0 or more symbols.
In regular expressions the standard notation
for this uses the star symbol: "I<item*>".

    { lhs => 'sequence', rhs => [qw(sequence_item)], min => 1 }

A C<min> of one means a sequence of 1 or more symbols.
In regular expressions the standard notation
for this uses the plus symbol: "I<item+>".

To keep things simple,
the right hand side of a sequence rule must a single symbol.
Of course, applications will often want to repeat sequences of multiple symbols,
but that is easy to do indirectly:

    { lhs => 'sequence', rhs => [qw(sequence_item)], min => 0 },
    { lhs => 'sequence_item', rhs => [qw(part1 part2)], },

Sequences can have a separator, specified
with the C<separator> rule property.
By default, separation is Perl-style:
trailing separators are allowed.
If you prefer "proper" separaration,
where separator symbols must actually separate symbols
and cannot come
after the last item of a sequence,
you can set
the C<proper> rule property.

You are never forced to use sequence rules.
But it's usually better to use the sequence rules where you can.
Marpa optimizes for sequences.

The semantics for a sequence rule
are implemented by a single Perl closure.
This is often more natural than spreading
the sequence's semantics out over two or more Perl closures,
which is usually necessary when a sequence is written out
as non-sequence rules.
See L<the section on sequences in the semantics
document|Marpa::Semantics//Sequences>.

Marpa throws an exception if you try to use a nullable symbol
as the right hand side of a sequence rule,
or as the separator for a sequence rule.
The ban on nullables in sequences only applies to sequences in sequence productions.
Nothing prevents you from specifying a sequence of nullables using non-sequence rules.

=head3 The action Rule Property

The value of the C<action> rule property is a string which
expresses semantics.
Its standard use is as the name of
a Perl closure implementing the semantics for a rule.

=head3 The keep Rule Property

Separators in sequence rules
are usually not semantically
significant.
By default,
Marpa throws away
separators during parse tree traversal and
before node evaluation time,
so that the semantic actions
do not see the separators.

If the value of the C<keep> rule property
is a Perl true, Marpa keeps separators.
This allows the semantic actions to examine them.
The downside
is that the
work of distinguishing
sequence separators from sequence items
is pushed into the semantic actions.

=head3 The lhs Rule Property

The value of the C<lhs> rule property must be a string containing
the name of the rule's left hand side symbol.
Every Marpa rule must have a left hand side symbol.

=head3 The min Rule Property

C<min> must be undefined, 0 or 1.
If C<min> is 0 or 1, 
the rule is a B<sequence production>.
If C<min> is undefined, the rule is an ordinary, B<non-sequence production>.

Only one symbol is allowed on the right hand side of a sequence production,
and the right hand side symbol may not be a nullable symbol.
The input will be required to match
the rhs symbol at least C<min> times
and will be allowed to match an unlimited number of times.

=head3 The proper Rule Property

By default, sequence rules with separators allow trailing
separators,
Perl-style.
If the C<proper> rule property is a Perl true,
"proper" separation is enforced.
In proper separation,
separation must actually separate sequence items,
and trailing separators are not acceptable.

=head3 The priority Rule Property

The C<priority> rule property expresses semantics.
Its standard use is for ordering parses,
The Single Parse Evaluator simply ignores it.
The L<document for the Multi-parse
Evaluator|Marpa::Evaluator//>
describes its semantics in that evaluator.

=head3 The rhs Rule Property

The value of the C<rhs> property is a reference to
an array of strings containing
the names of the rule's right hand symbols,
in order.
This array may be zero length, in which case
this is an B<empty rule> --
a rule with no symbols on the right hand side.
A rule is also empty if
there is no C<rhs> specifier in its descriptor.

=head3 The ranking_action Rule Property

The C<ranking_action> rule property expresses semantics.
Its standard use is to order parses.
The Single Parse Evaluator simply ignores it.
The L<document for the Multi-parse
Evaluator|Marpa::Evaluator//>
describes its semantics in that evaluator.

=head3 The separator Rule Property

Any sequence production may have a C<separator> defined.
The value must be a symbol name.
By default, Marpa allows trailing separators.
This is the usual style in Perl.
The separator must not be a nullable symbol.

=head2 Short Form Rule Descriptors

=for Marpa::Display
name: Engine Synopsis Ambiguous Parse
partial: 1
normalize-whitespace: 1

    rules => [
        [ 'E', [qw/E Add E/],      'do_add' ],
        [ 'E', [qw/E Multiply E/], 'do_multiply' ],
        [ 'E', [qw/Number/], ],
    ],

=for Marpa::Display::End

Rule descriptors may be given in "short form" --
as references to arrays.
The elements of the array,
in order,
are
the C<lhs> property,
the C<rhs> property,
the C<action> property
and the C<priority> property.
The last three are optional.
Omission of an optional
property in a short form descriptor
has the same effect 
that omitting the same optional property would have
in the long form.

=head2 Duplicate Rules

Marpa throws an exception if a duplicate rule is added.
For BNF productions, a rule is considered a duplicate if it has the
same left hand side symbol,
and the same symbols in the same order on the right hand side.
For sequences, a rule is considered a duplicate if it has the same
left hand symbol, the same right hand side symbol,
and the same separator.

=head1 SYMBOLS

=head2 The null_action Symbol Property

=head2 The terminal Symbol Property

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2010 Jeffrey Kegler, all rights reserved.
Marpa is free software under the Perl license.
For details see the LICENSE file in the Marpa distribution.

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
