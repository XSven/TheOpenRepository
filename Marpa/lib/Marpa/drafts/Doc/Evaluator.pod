=head1 NAME

Marpa::API::Evaluator - Marpa Evaluator Objects

=head1 SYNOPSIS

=begin Marpa::Test::Display:

## next 3 displays
in_file($_, 't/equation_s.t')

=end Marpa::Test::Display:

    my $fail_offset = $lexer->text('2-0*3+1');
    if ( $fail_offset >= 0 ) {
        Marpa::exception("Parse failed at offset $fail_offset");
    }

    my $evaler = Marpa::Evaluator->new( { recognizer => $recce } );
    Marpa::exception('Parse failed') if not $evaler;

    my $i = 0;
    while ( defined( my $value = $evaler->value() ) ) {
        my $value = ${$value};
        Test::More::ok( $expected_value{$value}, "Value $i (unspecified order)" );
        delete $expected_value{$value};
        $i++;
    } ## end while ( defined( my $value = $evaler->value() ) )

=head1 DESCRIPTION

    Marpa::Evaluator::audit
    Marpa::Evaluator::new
    Marpa::dump_sort_key
    Marpa::Evaluator::show_sort_keys
    Marpa::Evaluator::show_and_node
    Marpa::Evaluator::show_or_node
    Marpa::Evaluator::show_bocage
    Marpa::Evaluator::show_ambiguity
    Marpa::Evaluator::set
    Marpa::Evaluator::value

        infinite_rewrite
        max_parses
        parse_order
        trace_actions
        trace_evaluation
        trace_file_handle
        trace_tasks
        trace_values

     Remember that symbol ranking_action's are used for null values.

Parses are found and evaluated by Marpa's evaluator objects.
Evaluators are created with the C<new> constructor,
which requires a Marpa recognizer object
as an argument.

Marpa allows ambiguous parses, so evaluator objects are iterators.
Iteration is performed with the C<value> method,
which returns a reference to the value of the next parse.
Often only the first parse is needed,
in which case the C<value> method can be called just once.

By default, the C<new> constructor clones the recognizer, so that
multiple evaluators do not interfere with each other.

=head2 Null Values

A "null value" is the value used for a symbol when it is nulled in a parse.
The default null value is a Marpa option (C<default_null_value>).
If the application does not set the default null value,
it is a Perl undefined.

Each symbol can have its own null symbol value.
The null symbol value for any symbol is calculated using the null symbol action.
The B<null symbol action> for a symbol is the action
specified for the empty rule with that symbol on its left hand side.
The null symbol action is B<not> a rule action.
It's a property of the symbol, and applies whenever the symbol is nulled,
even when the symbol's empty rule is not involved.

For example, in MDL,
the following says that whenever the symbol C<A> is nulled,
its value should be a string that says it is missing.

=begin Marpa::Test::Commented_out_Display:

## next display
in_file($_, 'example/null_value.marpa');

=end Marpa::Test::Commented_out_Display:

=begin Marpa::Test::Display:

## skip display

=end Marpa::Test::Display:

    A: . q{'A is missing'}.

Null symbol actions are evaluated differently from rule actions.
Null symbol actions are run at evaluator creation time and the value of the result
at that point
becomes fixed as the null symbol value.
This is not the case with rule actions.
During the creation of the evaluator object,
rule actions are B<compiled into closures>.
During parse evaluation,
whenever a node for that rule needs its value recalculated,
the compiled rule closure is run.
A compiled rule closure
can produce a different value every time it runs.

I treat null symbol actions differently for efficiency.
They have no child values,
and a fixed value is usually what is wanted.
If you want to calculate a symbol's null value with a closure run at parse evaluation time,
the null symbol action can return a reference to a closure.
Rules with that nullable symbol in their right hand side
can then be set up to run that closure.

=head3 Evaluating Null Subtrees

A null derivation may consist of many steps and may contain many symbols.
Marpa's rule is that the value of a null subtree is
the null symbol value of the left hand side
of rule for the B<topmost node> of the
subtree.

=head1 METHODS

=head2 new

=begin Marpa::Test::Display:

## next display
in_file($_, 't/equation_s.t');

=end Marpa::Test::Display:

    my $evaler = Marpa::Evaluator->new(
      { recognizer => $recce }
    );

Z<>

=begin Marpa::Test::Display:

## next display
in_file($_, 'author.t/misc.t');

=end Marpa::Test::Display:

    my $evaler = Marpa::Evaluator->new( {
        recce => $recce,
        end => $location,
        clone => 0,
    } );

The C<new> method's one, required, argument is a hash reference of named
arguments.
The C<new> method either returns a new evaluator object or throws an exception.
The C<recognizer> option is required,
Its value must be a recognizer object which has finished recognizing a text.
The C<recce> option is a synonym for the the C<recognizer> option.

By default,
parsing ends at the default end of parsing,
which was set in the recognizer.
If an C<end> option is specified, 
it will be used as the number of the earleme at which to end parsing.

If the C<clone> argument is set to 1,
C<new> clones the recognizer object, so that multiple
evaluators do not interfere with each other's data.
This is the default and is always safe.
If C<clone> is set to 0, the evaluator will work directly with
the recognizer object which was its argument.
See L<above|/"Cloning"> for more detail.

Marpa options can also
be named arguments to C<new>.
For these, see L<Marpa::Doc::Options>.

=head2 set

=begin Marpa::Test::Display:

## next display
is_file($_, 'author.t/misc.t', 'evaler set snippet')

=end Marpa::Test::Display:

    $evaler->set( { trace_values => 1 } );

The C<set> method takes as its one, required, argument a reference to a hash of named arguments.
It allows Marpa options
to be specified for an evaluator object.
Relatively few Marpa options are not available at
evaluation time.
The options which are available
are mainly those which control evaluation time tracing.
C<set> either returns true or throws an exception.

=head2 value

=begin Marpa::Test::Display:

## next display
in_file($_, 't/ah2.t');

=end Marpa::Test::Display:

    my $result = $evaler->value();

Iterates the evaluator object, returning a reference to the value of the next parse.
If there are no more parses, returns undefined.
Successful parses may evaluate to a Perl 5 undefined,
which the C<value> method will return as a reference to an undefined.
Failures are thrown as exceptions.

When the order of parses is important,
it may be manipulated by assigning priorities to the rules and
terminals.
If a symbol can both match a token and derive a rule,
the token match always takes priority.
Otherwise the parse order is implementation dependent.

A failed parse does not always show up as an exhausted parse in the recognizer.
Just because the recognizer was active when it was used to create
the evaluator, does not mean that the input matches the grammar.
If it does not match, there will be no parses and the C<value> method will
return undefined the first time it is called.

=head1 CONTEXT-AWARE STATIC METHODS

    Only available to ranking actions!

Perl closures that run at node evaluation time have
available a set of B<context-aware static methods>.
A closure can use these methods to obtain various
data about the context in which it is called.

=head2 Marpa::cause_location

=head2 Marpa::length

=head2 Marpa::location

=head2 Marpa::token_location

=head1 Appendix: Infinitely Ambiguous Grammars

The fast evaluator did not allow a
grammar to be B<infinitely> ambigious.
That is, the grammar had to be such that,
for all possible inputs,
the list of parses must eventually terminate.
In practice, this is not likely to be
a real restriction.
Ambiguous grammars have their uses,
but infinitely ambiguous grammars are almost always
mistakes, pure and simple.

An example of an infinitely ambiguous grammar is the following:

    S ::= A
    A ::= B
    B ::= A
    B :: 'x'

Given the input 'x', this grammar will produce
these parses 
 
    S -> A -> B -> x
    S -> A -> B -> A -> B -> x
    S -> A -> B -> A -> B -> x -> A -> B -> x
    .
    .
    .

Because of the two rules C<A ::= B> and C<B ::= A>,
this list of parses could go on forever.
The two rules C<A ::= B> and C<B ::= A> form what is called a B<cycle>.

If you want to use the fast evaluator,
there's an easy way to do it --
rewrite the grammar, eliminating the cycle.
It probably was a mistake in the first place.
Even if it wasn't the cycle will usually be easy to live without.

While it is unlikely the user will want to work with an
infinitely ambiguous grammars, Marpa allows this.
It is quite possible the user will want to see all the
parses for an ambiguous grammar.
It is also quite possible a Marpa application
will want only one parse result
in an ambiguous parse,
but will care which one it sees.
If your parse
has any of the above three requirements,
you will need
the more powerful evaluator:
L<Marpa::API::Evaluator>.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2010 Jeffrey Kegler, all rights reserved.
Marpa is free software under the Perl license.
For details see the LICENSE file in the Marpa distribution.

=cut
