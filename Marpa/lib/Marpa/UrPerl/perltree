#!/usr/bin/perl

use 5.010;
use strict;
use warnings;
use English qw( -no_match_vars );
use PPI;
use Data::Dumper;

use lib 'lib';
use Marpa;

my $draft_grammar = <<'END_OF_GRAMMAR';
prog  progstart lineseq
block  LBRACE remember lineseq RBRACE
remember
mydefsv
progstart
mblock  LBRACE mremember lineseq RBRACE
mremember
lineseq
lineseq lineseq decl
lineseq lineseq line
line  label cond
line loop
line switch
line label case
line label SEMICOLON
line label sideff SEMICOLON
sideff error
sideff expr
sideff expr IF expr
sideff expr UNLESS expr
sideff expr WHILE expr
sideff expr UNTIL iexpr
sideff expr FOR expr
else
else ELSE mblock
else ELSIF LPAREN mexpr RPAREN mblock else
cond IF LPAREN remember mexpr RPAREN mblock else
cond UNLESS LPAREN remember miexpr RPAREN mblock else
case WHEN LPAREN remember mexpr RPAREN mblock
case DEFAULT block
cont
cont CONTINUE block
loop label WHILE LPAREN remember texpr RPAREN mintro mblock cont
loop label UNTIL LPAREN remember iexpr RPAREN mintro mblock cont
loop label FOR MY remember my_scalar LPAREN mexpr RPAREN mblock cont
loop label FOR scalar LPAREN remember mexpr RPAREN mblock cont
loop label FOR LPAREN remember mexpr RPAREN mblock cont
loop label FOR LPAREN remember mnexpr SEMICOLON texpr SEMICOLON mintro mnexpr RPAREN mblock
loop label block cont
switch label GIVEN LPAREN remember mydefsv mexpr RPAREN mblock
mintro
nexpr
nexpr sideff
texpr
texpr expr
iexpr expr
mexpr expr
mnexpr nexpr
miexpr iexpr
label
label LABEL
decl format
decl subrout
decl mysubrout
decl package
decl use
decl peg
peg PEG
format FORMAT startformsub formname block
formname WORD
formname
mysubrout MYSUB startsub subname proto subattrlist subbody
subrout SUB startsub subname proto subattrlist subbody
startsub
startanonsub
startformsub
subname WORD
proto
proto THING
subattrlist
subattrlist COLONATTR THING
subattrlist COLONATTR
myattrlist COLONATTR THING
myattrlist COLONATTR
subbody block
subbody SEMICOLON
package PACKAGE WORD SEMICOLON
use USE startsub WORD WORD listexpr SEMICOLON
expr expr ANDOP expr
expr expr OROP expr
expr expr DOROP expr
expr argexpr
argexpr argexpr COMMA
argexpr argexpr COMMA term
argexpr term
listop LSTOP indirob argexpr
listop FUNC LPAREN indirob expr RPAREN
listop term ARROW method LPAREN listexprcom RPAREN
listop term ARROW method
listop METHOD indirob listexpr
listop FUNCMETH indirob LPAREN listexprcom RPAREN
listop LSTOP listexpr
listop FUNC LPAREN listexprcom RPAREN
listop LSTOPSUB startanonsub block listexpr
method METHOD
method scalar
subscripted    star LBRACE expr SEMICOLON RBRACE
subscripted scalar LSQUARE expr RQUARE
subscripted term ARROW LSQUARE expr RQUARE
subscripted subscripted LSQUARE expr RQUARE
subscripted scalar LBRACE expr SEMICOLON RBRACE
subscripted term ARROW LBRACE expr SEMICOLON RBRACE
subscripted subscripted LBRACE expr SEMICOLON RBRACE
subscripted term ARROW LPAREN RPAREN
subscripted term ARROW LPAREN expr RPAREN
subscripted subscripted LPAREN expr RPAREN
subscripted subscripted LPAREN RPAREN
subscripted LPAREN expr RPAREN LSQUARE expr RQUARE
subscripted LPAREN RPAREN LSQUARE expr RQUARE
termbinop term ASSIGNOP term
termbinop term POWOP term
termbinop term MULOP term
termbinop term ADDOP term
termbinop term SHIFTOP term
termbinop term RELOP term
termbinop term EQOP term
termbinop term BITANDOP term
termbinop term BITOROP term
termbinop term DOTDOT term
termbinop term ANDAND term
termbinop term OROR term
termbinop term DORDOR term
termbinop term MATCHOP term
termunop MINUS_SIGN term
termunop PLUS_SIGN term
termunop BANG term
termunop TILDE term
termunop term POSTINC
termunop term POSTDEC
termunop PREINC term
termunop PREDEC term
anonymous LSQUARE expr RQUARE
anonymous LSQUARE RQUARE
anonymous HASHBRACK expr SEMICOLON RBRACE
anonymous HASHBRACK SEMICOLON RBRACE
anonymous ANONSUB startanonsub proto subattrlist block
termdo DO term
termdo DO block
termdo DO WORD LPAREN RPAREN
termdo DO WORD LPAREN expr RPAREN
termdo DO scalar LPAREN RPAREN
termdo DO scalar LPAREN expr RPAREN
term termbinop
term termunop
term anonymous
term termdo
term term QUESTIONMARK term COLON term
term REFGEN term
term myattrterm
term LOCAL term
term LPAREN expr RPAREN
term LPAREN RPAREN
term scalar
term star
term hsh
term ary
term arylen
term       subscripted
term ary LSQUARE expr RQUARE
term ary LBRACE expr SEMICOLON RBRACE
term THING
term amper
term amper LPAREN RPAREN
term amper LPAREN expr RPAREN
term NOAMP WORD listexpr
term LOOPEX
term LOOPEX term
term NOTOP argexpr
term UNIOP
term UNIOP block
term UNIOP term
term REQUIRE
term REQUIRE term
term UNIOPSUB
term UNIOPSUB term
term FUNC0
term FUNC0 LPAREN RPAREN
term FUNC0SUB
term FUNC1 LPAREN RPAREN
term FUNC1 LPAREN expr RPAREN
term PMFUNC LPAREN argexpr RPAREN
term WORD
term listop
myattrterm MY myterm myattrlist
myattrterm MY myterm
myterm LPAREN expr RPAREN
myterm LPAREN RPAREN
myterm scalar
myterm hsh
myterm ary
listexpr
listexpr argexpr
listexprcom
listexprcom expr
listexprcom expr COMMA
my_scalar scalar
amper AMPERSAND indirob
scalar DOLLAR_SIGN indirob
ary AT_SIGN indirob
hsh PERCENT_SIGN indirob
arylen DOLSHARP indirob
star STAR indirob
indirob WORD
indirob scalar
indirob block
indirob PRIVATEREF
END_OF_GRAMMAR

my @terminals = qw(
ADDOP AMPERSAND ANDAND ANDOP ANONSUB ARROW ASSIGNOP AT_SIGN BANG BITANDOP BITOROP COLON COLONATTR
COMMA CONTINUE DEFAULT DO DOLLAR_SIGN DOLSHARP DORDOR DOROP DOTDOT ELSE ELSIF EQOP FOR FORMAT FUNC
FUNC0 FUNC0SUB FUNC1 FUNCMETH GIVEN HASHBRACK IF LABEL LBRACE LOCAL LOOPEX LPAREN LSQUARE LSTOP
LSTOPSUB MATCHOP METHOD MINUS_SIGN MULOP MY MYSUB NOAMP NOTOP OROP OROR PACKAGE PEG PERCENT_SIGN
PLUS_SIGN PMFUNC POSTDEC POSTINC POWOP PREDEC PREINC PRIVATEREF QUESTIONMARK RBRACE REFGEN RELOP
REQUIRE RPAREN RQUARE SEMICOLON SHIFTOP STAR SUB THING TILDE UNIOP UNIOPSUB UNLESS UNTIL USE
WHEN WHILE WORD
error
);

my %word_to_token = (
);

my %operator_to_token = (
    'not' => 'NOTOP',
    '->' => 'ARROW',
    '=' => 'EQOP',
    'eq' => 'EQOP',
    ',' => 'COMMA',
    '=>' => 'COMMA',
    '=~' => 'MATCHOP',
    '+' => 'PLUS_SIGN',
    '-' => 'MINUS_SIGN',
);

my %structure_to_token = (
    ')' => 'RPAREN',
    '(' => 'LPAREN',
    ']' => 'RSQUARE',
    '[' => 'LSQUARE',
    '}' => 'RBRACE',
    '{' => 'LBRACE',
    ';' => 'SEMICOLON',
    ':' => 'COLON',
    ',' => 'COMMA',
);

my %things = (
    'PPI::Token::HereDoc' => 1,
    'PPI::Token::Number' => 1,
    'PPI::Token::Number::Float' => 1,
    'PPI::Token::Quote::Literal' => 1,
    'PPI::Token::Quote::Single' => 1,
    'PPI::Token::Quote::Double' => 1,
    'PPI::Token::QuoteLike::Words' => 1,
    'PPI::Token::Regexp::Match' => 1,
);

my @rules = ();
for my $draft_rule (split "\n", $draft_grammar)
{
    my @symbols = split ' ', $draft_rule;
    my $lhs = shift @symbols;
    push @rules, {
        lhs => $lhs,
        rhs => [ @symbols ],
        action => "!$lhs",
    };
}

my $grammar = Marpa::Grammar->new(
    {   start => 'prog',
        actions => 'main',
        rules   => \@rules,
        terminals      => \@terminals,
        default_action => 'default_action',
    }
);
$grammar->precompute();

my $source = do { local $RS = undef; <STDIN> };
my $Tokenizer = PPI::Tokenizer->new( \$source );
my @marpa_tokens = ();
TOKEN: while ( my $token = $Tokenizer->get_token() ) {
    next TOKEN if not $token->significant;
    my $type = ref $token;
    if ($type eq 'PPI::Token::Symbol') {
        my $content = $token->content;
        if ($content =~ /[$][_A-Za-z]/xms) {
            # This is a non-terminal in Perl,
            # but a terminal in PPI.
            push @marpa_tokens, [ 'scalar', $token->content ];
            next TOKEN;
        }
    }
    if ($things{$type}) {
        push @marpa_tokens, [ 'THING', $token->content ];
        next TOKEN;
    }
    if ( $type eq 'PPI::Token::Cast'
        and ( my $content = $token->content ) eq '\\' )
    {
        push @marpa_tokens, [ 'REFGEN', $content ];
        next TOKEN;
    } ## end if ( $type eq 'PPI::Token::CAST' and ( my $content =...))
    if ($type eq 'PPI::Token::Operator') {
        if (defined(
                my $marpa_token =
                    $operator_to_token{ my $content = $token->content }
            )
            )
        {
            push @marpa_tokens, [ $marpa_token, $content ];
            next TOKEN;
        } ## end if ( defined( my $marpa_token = $structure_to_token{...}))
    }
    if ($type eq 'PPI::Token::Structure') {
        if (defined(
                my $marpa_token =
                    $structure_to_token{ my $content = $token->content }
            )
            )
        {
            push @marpa_tokens, [ $marpa_token, $content ];
            next TOKEN;
        } ## end if ( defined( my $marpa_token = $structure_to_token{...}))
    }
    say +(ref $token), q{: }, $token->content;
}

exit 0;

my $recce = Marpa::Recognizer->new( { grammar => $grammar } );

my $lexer = Marpa::MDLex->new(
    {   recognizer => $recce,
        terminals  => [
            [ 'Number',     '\d+' ],
            [ 'Minus',      '[-]' ],
            [ 'MinusMinus', '[-][-]' ],
        ]
    }
);

$recce->tokens();

my $evaler = Marpa::Evaluator->new( { recce => $recce, clone => 0 } );
Marpa::exception('Could not initialize parse') if not $evaler;

my $value_ref = $evaler->value();

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
