#!/usr/bin/perl

use 5.010;
use strict;
use warnings;
use English qw( -no_match_vars );
use Marpa::UrHTML;
use List::Util qw(sum);
use WWW::Mechanize;

my $locator = shift;
my $document;
if ($locator =~ /^[a-zA-Z0-9]+[:]/) {
    require WWW::Mechanize;
    my $mech = WWW::Mechanize->new( autocheck => 1 );
    $mech->get( $locator );
    $document = $mech->content;
    undef $mech;
} else {
    local $RS = undef;
    open my $fh, q{<}, $locator;
    $document = <$fh>;
    close $fh;
}

sub calculate_max_depths {
    my ($child_data) = @_;
    my %return_depths = ( ANY => 0 );
    for my $child_value ( grep { ref $_ } map { $_->[0] } @{$child_data} ) {
        my $depths = $child_value->{depths};
        CHILD_TAGNAME: for my $child_tagname ( keys %{$depths} ) {
            my $depth = $depths->{$child_tagname};
            if ( $depth > ( $return_depths{$child_tagname} // 0 ) ) {
                $return_depths{$child_tagname} = $depth;
            }
            if ( $depth > $return_depths{ANY} ) {
                $return_depths{ANY} = $depth;
            }
        } ## end for my $child_tagname ( keys %{$depths} )
    } ## end for my $child_value ( grep { ref $_ } map { $_->[0] }...)
    return \%return_depths;
} ## end sub calculate_max_depths

sub calculate_length {
    my ($child_data) = @_;
    my $length = 0;
    CHILD: for my $child_data ( @{$child_data} ) {
        my ( $value, $literal ) = @{$child_data};
        if ( defined $value ) {
            $length += $value->{length};
            next CHILD;
        }
        $length += ( $literal =~ tr/\t\f \x{200B}//c );
    } ## end for my $child_data ( @{$child_data} )
    return $length;
} ## end sub calculate_length

my ( $instance, $value ) = @{ Marpa::UrHTML->new(
        {   handlers => [
                [ ':COMMENT' => sub { return { depths => {}, length => 0 } }
                ],
                [   q{*} => sub {
                        my $child_data =
                            Marpa::UrHTML::child_data('value,literal');
                        my $tagname = Marpa::UrHTML::tagname();
                        my $length  = calculate_length($child_data);
                        $Marpa::UrHTML::INSTANCE->{count}->{$tagname}++;
                        $Marpa::UrHTML::INSTANCE->{length}->{$tagname}
                            += $length;
                        my $return_depths = calculate_max_depths($child_data);
                        ( $return_depths->{$tagname} //= 0 )++;
                        $return_depths->{ANY}++;
                        return {
                            depths => $return_depths,
                            length => $length,
                        };
                    },
                ],
                [   ':TOP' => sub {
                        my $child_data =
                            Marpa::UrHTML::child_data('value,literal');
                        return [
                            $Marpa::UrHTML::INSTANCE,
                            {   depths => calculate_max_depths($child_data),
                                length => calculate_length($child_data),
                            },
                        ];
                    },
                ],
            ],
        }
        )->parse( \$document )
    };

my $length_by_element = $instance->{length};
my $count_by_element = $instance->{count};
my $html_length = $length_by_element->{html};
my $total_lengths = List::Util::sum values %{ $length_by_element };
my $complexity = sprintf "%.3f", ($total_lengths / ($html_length * log ($html_length)));
my $max_depths = $value->{depths};
my $max_element_depth = $max_depths->{ANY};
delete $max_depths->{ANY};

print qq{<table cellpadding="3" border="1">}
    . qq{<thead>\n}
    . qq{<tr><th colspan="5">$locator</tr>\n}
    . qq{<tr><th colspan="5">Complexity Score = $complexity</tr>\n}
    . qq{<tr><th colspan="5">Maximum Depth = $max_element_depth</tr>\n}
    . qq{<tr>}
    . qq{<th>Element}
    . qq{<th>Maximum<br>Nesting}
    . qq{<th>Number of<br>Elements}
    . qq{<th>Size in<br>Characters</th>}
    . qq{<th>Average<br>Size</th>}
    . qq{</tr>\n}
    . qq{</thead>\n};

for my $element ( sort keys %{$max_depths} ) {
    my $count = $count_by_element->{$element};
    my $size  = $length_by_element->{$element};
    my $average = $count ? int( $size / $count ) : q{-};
    print join q{},
        q{<tr>},
        qq{<td>$element</td>},
        q{<td align="right">}, $max_depths->{$element}, q{</td>},
        qq{<td align="right">$count</td>},
        qq{<td align="right">$size</td>},
        qq{<td align="right">$average</td>},
        "</tr>\n";
} ## end for my $element ( sort keys %{$max_depths} )

print qq{</table>\n};

exit 0;

__END__

=head1 NAME

C<urhtml_score> - Show complexity metric and other stats for web page

=head1 SYNOPSIS

    ur_html_score [uri|file]

=head1 EXAMPLE

    urhtml_score http://perl.org

=head1 DESCRIPTION

Given a URI, parses it as HTML and prints a complexity metric and other statistics.
The complexity metric is the average depth (or nesting level), in elements, of a character,
divided by the logarithm of the length of the HTML.

Other statistics follow, formatted as an HTML table.
There is a row for each element type,
with

=over 4

=item *
The maximum nesting depth of that element (this time only taking into
account nesting within that particular element).

=item *
A count of the elements of that kind in the document

=item *
The total number of character in elements of that type.
This counts characters in nested elements multiple times.
For example, if a page contains a table within a table,
characters in the inner table will be counted twice.

=item *
The average size of elements of this type, in characters.

=back

Here is the first part of the output for the C<http://perl.org>.

   http://perl.org
   Complexity = 0.746

   Element Maximum Number of   Size in   Average
           Nesting Elements  Characters   Size
   a             1        56      3634      64
   body          1         1     12171   12171
   div           5        30     33605    1120
   em            1         1        13      13
   h1            1         1        60      60
   h4            1        11       932      84

=head1 THE COMPLEXITY METRIC

I originally was tempted to call the complexity metric a "quality metric",
but decided that was going too far.
Well designed websites often have low numbers, but high numbers don't
mean low quality -- it depends on what the mission is, and how well
complexity is being leveraged to serve that mission.

To obtain the complexity metric,
the nesting depth of the average character is divided by the logarithm
of the length of the HTML.
This the idea is that as a web page grows,
all else being equal,
it is reasonable for the
nesting depth to grow logarithmically, but no
faster.

How seriously should you take any of this?
I am frankly not sure.
The main purpose of this program was not to analyze web pages,
but to draw attention to the underlying technology.
Speaking of which ...

=head1 PURPOSE

This program is a demo of a demo.
It purpose is to show how easy it is to write applications which look
at the structure of web pages using L<Marpa::UrHTML>.
And the purpose of L<Marpa::UrHTML>
is to demonstrate the power of its parse engine,
L<Marpa>.

Determining the structure of an HTML document has in the past
been considered a very difficult programming task,
requiring lots of special case coding.
L<Marpa::UrHTML> was written in a few days,
and the resulting grammar and code is natural and straight-forward.

At this stage of its development,
other parsers have advantages over L<Marpa::UrHTML>.
But they need to be perfect.
Because the code in them is an excruciatingly complex set of ad hoc
solutions to special cases,
other parsers are very hard to understand,
and therefore to modify.

As the documentation will show,
the HTML parsing logic in L<Marpa::UrHTML>,
is straightforward
and an extremely natural way of expressing the
problem.
The transparency of L<Marpa::UrHTML> is made possible
by L<Marpa>.

=head1 AUTHOR

Jeffrey Kegler

=head1 BUGS

Please report any bugs or feature requests to
C<bug-parse-marpa at rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Marpa>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Marpa
    
You can also look for information at:

=over 4

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Marpa>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Marpa>

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Marpa>

=item * Search CPAN

L<http://search.cpan.org/dist/Marpa>

=back

=head1 ACKNOWLEDGMENTS

The starting template for this code was
HTML::TokeParser, by Gisle Aas.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2009 Jeffrey Kegler, all rights reserved.

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl 5.10.0.

=cut
