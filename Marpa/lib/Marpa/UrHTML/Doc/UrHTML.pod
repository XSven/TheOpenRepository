=head1 NAME

Marpa::UrHTML - High-level HTML Parser

=head1 SYNOPSIS

    use Marpa::UrHTML;
    my $p1 = Marpa::UrHTML->new($urhtml_args);
    print Marpa::UrHTML->new($urhtml_args)->parse( \$document );
    my $p = Marpa::UrHTML->new( { handlers => \@handlers, } );

=head1 DESCRIPTION

L<Marpa::UrHTML> does "high-level" parsing of HTML.
Low-level HTML parsing is converting an HTML document into a series of tokens.
High-level HTML parsing is determining the overall structure of the document.
L<Marpa::UrHTML> allows the user to specify handlers to be called on the various
elements and non-elements of an HTML document.

=head2 How L<Marpa::UrHMTL> looks at HTML

L<Marpa::UrHTML> is an extremely liberal HTML parser.
L<Marpa::UrHTML> will treat any document as HTML, if perhaps
invalid or broken HTML, and parse accordingly.

Every SGML/HTML document contains an SGML prolog, an C<html> element,
and an SGML trailer.  The SGML prologs and trailer can be zero length.
The C<html> element consists of a start tag C<< <html> >>,
an end tag C<< </html> >>
and the text between them, called the "contents".
in which case they are also said to be "virtual" tags.
The contents of the C<html> element may be zero length.

In the contents of the C<html> element can be other elements.
Capitalization is significant here,
The "C<html> element" is not the same as an "HTML element".
The B<html element> is the top-level element in any HTML document,
and will be unique in a valid document.
Contained in the C<html> element can be many B<HTML elements>.

Every element has a B<tagname>.
In a valid HTML document,
only the C<html> element will have the tagname "C<html>".

Start tags and end tags may be missing.
This is legal for the many HTML elements,
including the C<html> element itself.
B<Missing tags> are also called B<implicit> or B<virtual tags>.
An tag which is not missing is an B<explicit tag>.

The contents of HTML elements,
in addition to other HTML elements,
can include B<non-elements>.
The trailer and prolog will be entirely non-elements.
HTML elements can contain both elements and non-elements.
In the following HTML fragment

    <p>I say<q>hello</q>I don't know why you say<q>goodbye</q></p>

the C<p> element contains two child elements,
both C<q> elements.  It also contains two stretches of non-element
text, both of which begin with the word "C<I>" and end with the word
"C<say>".

L<Marpa::UrHTML>'s uses L<HTML::Parser> to do its low-level parsing,
or tokenization.
L<HTML::Parser> returns six kinds of token.
B<start tag tokens> and B<end tag tokens> (or "start tokens"
and "end tokens") are always part of elements.
The non-element tokens are text, processing instructions, SGML declarations
and comments.

For liberal high-level parsing, L<Marpa::UrHTML> introduces a token type of its
own: cruft.
Cruft tokens are tokens which even L<Marpa::UrHTML>'s liberal
parsing standards cannot work into a reasonable HTML-like
structure.
L<Marpa::UrHTML> ignores cruft in determining the structure of
an HTML document, much as it the cruft were comments.

Text tokens are of three types: WHITESPACE, CDATA and PCDATA.
WHITESPACE is any text token composed entirely of whitespace
as defined in the HTML 4.01 specification
(L<http://www.w3.org/TR/html4/struct/text.html#h-9.1>).
A CDATA token is any non-WHITESPACE text token
returned by L<HTML::Parser>
with a true C<is_cdata> attribute.
All other tokens are PCDATA.
L<HTML::Parser> does not distinguish whitespace,
but L<Marpa::UrHTML> does because in the high-level
structure, whitespace is acceptable in places
where other text is not.

=head1 METHODS

=over

=item new

    my $urhtml = Marpa::UrHTML->new($urhtml_args);

The C<new> method returns a new L<Marpa::UrHTML> document.
Its arguments are references to hashes of named arguments.
Handlers and other options may be specified,
L<as described below|//"Options>.
If no arguments are supplied, the result of the parse
will be a copy of the input.

=item parse

    print $urhtml->parse( \$document );

The C<parse> method takes a reference to a string as its only,
required,
argument.
This string will be treated as HTML and parsed.
L<Marpa::UrHTML> objects are good for one parse only --
for a new parse, a
new L<Marpa::UrHTML> object should be created.

=back

=head2 Options to the C<new> method

=over

=item C<handlers>

The most important L<Marpa::UrHTML> option is the handlers option.
It is a reference to an array of handler declarations.
The handler declaration may either be short form (references to arrays of two elements)
or long form (hash refs).

=item C<trace_conflicts>

A boolean which turns on tracing of parse conflicts.
These should not be of interest to the average user.

=item C<trace_terminals>

A boolean which turns on tracing of terminals.

=item C<trace_fh>

A file handle.  Warning and diagnostics are printed to C<trace_fh>.

=back

=head2 Handler Declarations (Short Form)

Handler specs can be either array pointers (short form),
or hash pointers (long form).
The short, array form is the usual form.
The long, hash form can be useful for dealing when
element or class names with unusual characters.

A short (or array) form handler spec is a pointer to
an array of two elements.
The first is a string containing
a CSS-style specification.
The second element is the handler closure.
Here's an example:

    Marpa::UrHTML->new( { handlers => [ 'spacer' => \&delete_spacers ] } );

In this example, the specifier is C<spacer>.
When the specifier is a lowercase bareword,
it's taken as a tag name.
The C<spacer> specification indicates
that the closure should be called on all elements with the C<spacer> tagname.
The above code tells L<Marpa::UrHTML> to delete all C<spacer> elements.
(C<spacer> was a tag to add white space supported by
older versions of the Netscape browser.)

The handler specifications follow CSS B<style>, because it is handy
and likely to be familiar to the user.
The syntax is outlined in detail below, but
the following two rules sum it up:

    Use lowercase except for syntax special to L<Marpa::UrHTML>.
    Simple things work, irrelevant and complicated things don't.

HTML class names can also be in specifiers.  For example

    [ '.zipcode' => \&normalize_zipcode } ]

indicates that the C<normalize_zipcode> subroutine is the handler for
all elements whose class is zipcode.

A dotted pair of lowercase names specifies a handler that applies only
to elements with a specific tag name and class name.
For example,

    [ 'span.zipcode' => \&normalize_zipcode ]

indicates that C<normalize_zipcode> is the handler
for C<span> elements whose class attribute is "C<zipcode>".

As a special case, a handler specifier consisting of just an asterisk
is a wildcard matching all elements.

    [ q{*} => \&normalize_whitespace ]

L<Marpa::UrHTML> pseudo specifiers use the same syntax
except that lowercase is reserved for CSS pseudo-classes,
none of which 
L<Marpa::UrHTML> supports as of this version.
L<Marpa::UrHTML>'s pseudo-classes must always be specified in upper-case.

L<Marpa::UrHTML>'s initially receives its input as tokens
from L<HTML::Parser>.
The following
L<Marpa::UrHTML>'s pseudo-classes allow handlers to be assigned
to deal with certain
L<HTML::Parser> tokens as they come in:
C<:COMMENT>,
C<:PCDATA>
C<:PI>
and C<:CRUFT>.
These pseudo-classes assign handlers for comments,
PCDATA, SGML processing instructions, and cruft tokens, respectively.

   Supply pseudo-class examples.

The "top" handler is always the last to be called in any parse.
The "top" of the parse deals with a non-element -- the entire
physical document, including
the prolog, the trailer and the html element.
The default top handler takes the literal values of all of its
children and returns them as text.
It is very often useful for the user
to assign their own top handler.
The user can do this with the
C<:TOP> pseudo-class.

If a handler is specified for a tagname, it is called
whenever that element is found,
regardless of whether it has an explicit start
tag or an explicit end tag.
Elements that might be recognized by L<Marpa::UrHTML>
even when there are no explicit tags for them are 
C<html>,
C<head>,
C<body>,
C<table>,
C<tbody>,
C<tr>,
and C<td>.
L<Marpa::UrHTML> is even more liberal in placing virtual end tags.
At the end of they physical file, for example,
L<Marpa::UrHTML> will create a virtual end tag for any element
which remains open.

On the other hand, any misplaced
start tag or end tags which end up being classified
as cruft will not cause the handler for that tagname
to be called.

A consequence of the these rules and the structure of
HTML is that in every parse,
the handler for the C<html>, C<head>, and <body> elements
will be called once and only once.
For example, in the following HTML,

     <title>Title</title><p>some text<head>

a handler for the head element will be called just once,
with "C<< <title>Title</title><p>some text<head> >>"
as its contents.
The misplaced "C<< <head> >>" start tag will be classified
as cruft.
It will be part of the original contents for a C<html>
and a C<body> handler, but
will not be in contents of any call to a handler for
a C<head> element.

In L<Marpa::UrHTML> handler specifiers,
elements and class names should be all alphanumerics, hyphens
and underscores.
Other characters are reserved for future syntax extensions.
If you need class or tag names with other characters,
you should use the hash form of handler specification,
where arbitrary characters can be put into either a class
or element name, with one restriction:
L<Marpa::UrHTML> currently restricts itself to L<HTML::Parser>'s
default handling of element tag names.
This follows the HTML standards (but B<not> the XML standards)
and treats tag names as case insensitive.

For elements, multiple specifiers can match.
When they do,
More narrowly targeted specifiers take precedence over less
narrowly targeted ones, with class taking precedence over tag name.
This means that a handler specifier for a specific tagname and
class takes precedence over one which is just for the class.
A handler specifier only specifying the class will take precedence
over one specifying only the tagname.
And a handler specifiying only the tagname takes precedence over
the wildcard handler for all elements.

For example, suppose a L<Marpa::UrHTML> object, is created as follows

    $urhtml = Marpa::UrHTML->new(
        {   handlers => [ q{*} => \&wildcard_handler ],
            [ 'div'        => \&div_handler ],
            [ '.class1'    => \&class1_handler ],
            [ 'div.class1' => \&div_class1_handler ]
        }
    );

handlers would be assigned as in this table.

    Element   Class       Handler
    'span'    'class1'    class1_handler1
    'span'    'class2'    wildcard_handler1
    'div'     'class1'    div_class1_handler1
    'div'     'class2'    div_handler1

    Actually write code for the above and create a test case.

     Casing:
     HTML elements NOT case-sensitive.
     XML elements case-sensitive.
     class names case-sensitive.
     CSS pseudo-classes NOT case-sensitive.

=head2 Handler Declarations (Long Form)

The action specifiers do not accept the CSS syntax escaping of characters.
Whatever merits would be alleged for this, it would be very awkward when combined with
Perl's own string escapes.
In the specifiers, all characters except alphanumerics, hyphen and underscore are
reserved for future extensions.

For elements and classnames with arbitrary names, or for any purpose
where it is convenient, there is a "long form"
for handler declarations.
The long form is a hash reference with these named args:

    element
    class
    pseudoclass
    action

Here's an example of a L<Marpa::UrHTML> object being created with
handlers declarations in the long form:

     Add example here.

=head2 How to Write I<Marpa::UrHTML> Actions

=head3 The Tree Method: It doesn't Fit HTML Very Well

The typical method of evaluating high-level parses
is to view the parse structure as an upside down
tree, with the root node at the top and the leaf nodes
at the bottom.
Leaf nodes have no children, but all others do.
The root node has no parent, but all the others do.

In the tree method the actions are assigned to nodes.
The actions are called recursively.
The result of each action becomes one of the arguments
to its parent node.
The result of the root node is the value of the whole parse.

What's the problem?  Consider this HTML fragment, an C<< <p> >> element:

     <p> I am&nbsp;text<br>
     </p><strong>more &nbsp;text </strong><br>
     Even&nbsp;more text<br>
     Yet more text
     </p>

From the point of view of a handler for the C<< <p> >> element,
how many children are there?
In the tradtional method, one part of the answer seems easy.
The C<< <strong> >> element should be a single child.
But even that is dubious.  The handler may be interested in a series
of text characters.
That the text characters are inside a 
C<< <strong> >> element may be useful information, but
the handler may want to conveniently subject both to the same kind
of processing?

And how should the non-element text be dealt with?
Is it two tokens?
Should an effort be made to keep consecutive stretches of text
in a single child.
By default, L<HTML::Parser> does not do so.
What about the whitespace?
And does the C< &amp;nbsp; > markup count as whitespace?

There is no one answer to questions like these that works
for all actions.
Evaluating HTML parses requires
an evaluation method more flexible than
the tree method.
Evaluating HTML parses requires
a method where the tree method is just one point of view.

=head3 The Domain Method

L<Marpa::UrHTML>'s actions have a domain.
The Domain API allows points of view to be taken of this domain.
Each domain corresponds to one or more consective characters of text in
the original document, and that is one point of view
-- the B<original text> point of view.

Domains are never zero-length, and they never overlap.
But a domain can contained another domain.
The containing domain is the B<parent domain>,
and the contained domain is a B<subdomain>
or B<child domain>.

A subdomain which has an action which returns a defined value
is an B<evaluated subdomain>.
The B<literal text> point of view is the same as the B<original text>
point of view, except where it contains an evaluated subdomain it replaces
the characters of the original text with the stringified value of that subdomain.
This means, for example, that actions which return a zero-length string have
the effect of deleting their domain from the literal text.

    After here -- left over from previous drafts

L<Marpa::UrHTML>'s actions get their data from calls to
the L<Marpa::UrHTML> API.
Each L<Marpa::UrHTML> object
also makes available to its handlers
a special variable for
data special to that object:
C<$Marpa::UrHTML::INSTANCE>.
C<$Marpa::UrHTML::INSTANCE> is initialized to
an empty hash.
Otherwise, what is done with it is completely up
to the user.
For example, where programming via side effects
is more natural that passing data up the parse
tree, 
C<$Marpa::UrHTML::INSTANCE> can be used to
store the data,
and the handler for the C<:TOP> pseudoclass
can return it as the value of the parse.

     Mention an example of this technique.

=head3 Nodes and Children

Actions can be called on elements and non-elements.
Collectively these are the B<nodes> of parse.

To keep the API model simple, 
L<Marpa::UrHTML> makes it appear to all actions
as if their nodes had at least one child node.
Even the actions for the token pseudoclasses,
like C<:PCDATA>,
appear to have a single child node -- the token.

=head3 Literal and Original Contents

The children of an action may be either B<evaluated>
or B<unevaluated>.
A child is evaluated if another handler 
was called on it and that 
other handler returned something other
than undef.
In any other case, the child is unevaluated.

=head3 The Action API: Simple Utilities

The C<child_data> API call, discussed below,
is the Swiss Army knife of the L<Marpa::UrHTML>
API, but much work can be done using 
the simpler utilites described in this section.

=over

=item C<attributes>

Returns a hash ref to the attributes of the start token.
This hash ref is exactly the hash ref returned
for the C<attr> arg specification of L<HTML::Parser>.
The C<attributes> API call
returns an empty hash
if there were no attributes,
if there was no start token for this element,
or if this handler is being called on a non-element.

=item C<child_values>

The C<child_values> call is for those cases where
only children with values are of interest.
It returns a pointer to an array of those values.
No elements of this array will be undefined --
children which did not have values are simply ignored.

=item C<contents>

For an element, returns its literal contents.
For an non-element, returns undef.

=item C<end_tag>

For an element with an explicit end tag,
returns the original text of the end tag.
Otherwise, returns undef.

=item C<literal>

Returns a string containing the literal contents
of the element or non-element.

=item C<literal_ref>

Returns a string containing a reference
to the literal contents
of the element or non-element.

=item C<offset>

=item C<original>

=item C<start_tag>

For an element with an explicit start tag,
returns the original text of the start tag.
Otherwise, returns undef.

=item C<tagname>

=item C<title>

=back

=head4 The C<child_data> API call.

    Marpa::UrHTML::child_data('value,literal');

=over

=item C<element>

=item C<value>

=item C<literal>

=item C<original>

=item C<pseudoclass>

=item C<token_type>

=back

=head1 AUTHOR

Jeffrey Kegler

=head1 BUGS

Please report any bugs or feature requests to
C<bug-marpa at rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Marpa>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

=begin Marpa::Test::Display:

## skip display

=end Marpa::Test::Display:

    perldoc Marpa
    
You can also look for information at:

=over 4

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Marpa>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Marpa>

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Marpa>

=item * Search CPAN

L<http://search.cpan.org/dist/Marpa>

=back

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2009 Jeffrey Kegler, all rights reserved.

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl 5.10.0.
