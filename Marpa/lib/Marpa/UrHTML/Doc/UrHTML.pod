=head1 NAME

Marpa::UrHTML - High-level HTML Parser

=head1 SYNOPSIS

Delete all tables:

=for Marpa::Display
name: 'UrHTML Synopsis: Delete Tables'
perltidy: '-dcsc -sil=0'

    use Marpa::UrHTML qw(urhtml);

    my $with_table = 'Text<table><tr><td>I am a cell</table> More Text';
    my $no_table   = urhtml( \$with_table, { table => sub { return q{} } });

=for Marpa::Display::End

Delete everything B<but> tables:

=for Marpa::Display
name: 'UrHTML Synopsis: Delete Everything But Tables'
perltidy: '-dcsc -sil=0'

    my %handlers_to_keep_only_tables = (
        table  => sub { return Marpa::UrHTML::original() },
        ':TOP' => sub { return \( join q{}, @{ Marpa::UrHTML::descendant_values() } ) }
    );
    my $only_table = urhtml( \$with_table, \%handlers_to_keep_only_tables );

=for Marpa::Display::End

The same logic works even if a table is very defective:

=for Marpa::Display
name: 'UrHTML Synopsis: Defective Tables'
perltidy: '-dcsc -sil=0'

    my $with_bad_table = 'Text<tr>I am a cell</table> More Text';
    my $only_bad_table =
        urhtml( \$with_bad_table, \%handlers_to_keep_only_tables );

=for Marpa::Display::End

Delete all comments:

=for Marpa::Display
name: 'UrHTML Synopsis: Delete Comments'
perltidy: '-dcsc -sil=0'

    my $with_comment = 'Text <!-- I am a comment --> I am not a comment';
    my $no_comment   = urhtml( \$with_comment,
        { ':COMMENT' => sub { return q{} } });

=for Marpa::Display::End

Change the title:

=for Marpa::Display
name: 'UrHTML Synopsis: Change Title'
perltidy: '-dcsc -sil=0'

    my $old_title = '<title>Old Title</title>A little html text';
    my $new_title = urhtml(
        \$old_title,
        {   'title' => sub { return '<title>New Title</title>' }
        }
    );

=for Marpa::Display::End

Delete all elements in with a class attribute
of "C<delete_me>":

=for Marpa::Display
name: 'UrHTML Synopsis: Delete by Class'
perltidy: '-dcsc -sil=0'

    my $stuff_to_be_edited = '<p>A<p class="delete_me">B<p>C';
    my $edited_stuff       = urhtml( \$stuff_to_be_edited,
        { '.delete_me' => sub { return q{} } });

=for Marpa::Display::End

L<Marpa::UrHTML> recognizes elements even if they have missing
start and/or end tags.
Since it knows about missing tags, it can add them:

=for Marpa::Display
name: 'UrHTML Synopsis: Supply Missing Tags'
perltidy: '-dcsc -sil=0'

    sub supply_missing_tags {
        my $tagname = Marpa::UrHTML::tagname();
        return if $empty_elements{$tagname};
        return ( Marpa::UrHTML::start_tag() // "<$tagname>\n" )
            . Marpa::UrHTML::contents() .
            ( Marpa::UrHTML::end_tag() // "</$tagname>\n" );
    }
    my $html_with_just_a_title = '<title>I am a title and That is IT!';
    my $valid_html_with_all_tags =
        urhtml( \$html_with_just_a_title, { q{*} => \&supply_missing_tags } );

=for Marpa::Display::End

L<Marpa::UrHTML> understands the hierarchical structure of HTML elements,
and calls its handlers recursively.
Finding the maximum nesting depth of the elements is straightforward:

=for Marpa::Display
name: 'UrHTML Synopsis: Maximum Element Depth'
perltidy: '-dcsc -sil=0'

    sub depth_below_me {
        return List::Util::max( 0, @{ Marpa::UrHTML::descendant_values() } );
    }
    my %handlers_to_calculate_maximum_element_depth = (
        q{*}   => sub { return 1 + depth_below_me() },
        ':TOP' => sub { return depth_below_me() },
    );
    my $maximum_depth_with_just_a_title = urhtml( \$html_with_just_a_title,
        \%handlers_to_calculate_maximum_element_depth );

=for Marpa::Display::End

Since L<Marpa::UrHTML> tracks actual elements, however tagged, the maximum
depth in elements is the same for C<$valid_html_with_all_tags>
and C<$html_with_just_a_title>.

=head1 DESCRIPTION

L<Marpa::UrHTML> does "high-level" parsing of HTML.
It allows handlers to be specified for elements, tokens and other
components in the hierarchical structure of an HMTL document.
L<Marpa::UrHTML> is an extremely liberal HTML parser.
L<Marpa::UrHTML> will treat all documents as HTML.
If they are not valid HTML according to any of the standards,
invalid or broken HTML, and does its best to organize
the document into
a reasonable parse structure.

=head1 THE C<urhtml> STATIC METHOD

There is only one, static, method in L<Marpa::UrHMTL>:
C<Marpa::UrHMTL::urhtml>.
C<urhtml> takes one or more arguments.
The first argument is required, and must be a pointer to
a string to be parsed as HTML.
The second and
subsequent arguments (all optional) are hash references
with handler descriptions.
(See L<the synopsis|//"SYNOPSIS"> for several examples of
calls using the C<urhtml> method.)

=head2 CSS-style Handler Options

Handler descriptions in L<Marpa::UrHTML> are key-value pairs
in a hash.
In each pair, the key is a CSS-style handler specifier,
and the value is a closure,
which is called the B<action> for the
handler.

Specifiers are "CSS-style" in the sense that they follow the syntax
of CSS in its most basic cases.  No attempt is made or is planned
to implement the full CSS specifier syntax, much of which is
irrelevant to L<Marpa::UrHTML>.

Specifier syntaxes that are supported are as follows:

=over

=item Element Specifiers

    head

If a specifier contains no special characters (meaning
anything except alphanumerics, hyphens and underscores, it is taken
as the name of an element.
Consistent with L<HTML::Parser>'s default behavior,
element names must be specified in lowercase.

In a defective HTML document, tags for an element may be missing,
of tags for an element may be found where the element cannot not exist
even by L<HTML::Parser>'s very liberal standards.
Where actual structure and tagging conflict,
L<HTML::Parser> follows the structure.
Following the structure means, for example,
that handlers for the C<html>, C<head>,
and C<body> elements will be called once and only once for every
document.

For example, Suppose that
a document starts with an untagged header,
but has a C<< <head> >> tag may come in the
middle of its C<< <body> >> element.
The action for a C<head> specifier, will be called on
the untagged header
The action for a C<head> specifier will
B<not> be called for any component
containing the stray
C<< <head> >> tag.

=item Class Specifiers

A specifier which begins with a dot or period (such as "C<.delete_me>")
will match any element whose class attribute is 
"C<delete_me>".

=item Element and Class Specifiers

A specifier which contains a dot or period somewhere other than
the first position (such as "C<span.label>")
is treated as a dotted tagname-class pair.
Its action will be called for
any component whose tagname and class attribute both match.

=item The Element Wildcard Specifier

A specifier of just an asterisk ("C<*>") matches all elements.
Be careful to note that matching all elements is B<not> the same
as matching all components.
The element wildcard specifier will not match any pseudoclasses.

=item Pseudoclass Specifiers

    ':COMMENT' => \&delete_it

A specifier which begins with a colon ("C<:>") is a pseudoclass.
L<Marpa::UrHTML> defines
pseudoclasses to deal with tokens and other non-element
components of the HTML hierarchy.

=back

=head3 Conflicting Specifiers

Specifiers for elements can conflict.
For example, suppose an element has the start tag C<< <div class="high"> >>.
Suppose further that 
the handler descriptions include these:

      div => \&div_action,
      high => \&high_class_action,
      'div.high' => \&div_high_action,
      q{*} => \&wildcard_action,

=for Marpa::Display
name: 'UrHTML Pod: Handler Precedence'
perltidy: '-dcsc -sil=0'

my $html = <<'END_OF_HTML';
<span class="high">High Span</span>
<span class="low">Low Span</span>
<div class="high">High Div</span>
<div class="low">Low Div</span>
END_OF_HTML

my $result = Marpa::UrHTML::urhtml( \$html,
    {   q{*} => sub {
            return "Wildcard handled: " . Marpa::UrHTML::contents() . "\n";
        },
        'html' => { return Marpa::UrHTML::literal() },
        'body' => { return Marpa::UrHTML::literal() },
        'div' => sub {
            return "Element handled: " . Marpa::UrHTML::contents() . "\n";
        },
        '.high' => sub {
            return "High Class handled: " . Marpa::UrHTML::contents() . "\n";
        },
        'div.high' => sub {
            return "Element.High handler: "
                . Marpa::UrHTML::contents() . "\n";
        },
    }
);

=for Marpa::Display::End

=for Marpa::Display
name: 'UrHTML Pod: Handler Precedence Result'


=for Marpa::Display::End

=head3 Gritty Details of the Handler Specifier Syntax

For elements and class names only alphanumerics, hyphens and underscores are supported.
Elements must be specified in lowercase, but will match any casing in the original
document.

Forcing element names to be lowercase follows the default behavior of
L<HTML::Parser>, which coerces all tagnames to lowercase.
This means tagnames matching is case-indifferent.
This is consistent with the HTML standards.
However, it is B<not> consistent with the XML standards,
and an option to change this behavior may be added in
the future.

Pseudoclass names special to
L<Marpa::UrHTML> are case-sensitive, and must be all uppercase.
Lowercase is reserved for CSS pseudoclasses.
The CSS standard specifies that its pseudoclass names are case-indifferent.
It does not at present seem useful to support any CSS pseudoclasses.

=head1 HOW TO WRITE ACTIONS

=head2 Non-elements and Tokens

L<Marpa::UrHTML>'s low-level parsing
uses L<HTML::Parser> to do its low-level parsing.
L<HTML::Parser> returns six kinds of token.
B<start tag tokens> and B<end tag tokens> (or "start tokens"
and "end tokens") are always part of elements.
L<HTML::Parser>'s non-element tokens are text, processing instructions, SGML declarations
and comments.

To meet L<Marpa::UrHTML>'s requirements for high-level parsing,
it introduces four new element tokens:
"cruft",
C<WHITESPACE>, C<CDATA> and C<PCDATA>.

The "cruft" token is introduced to allow liberal parsing,
in particular to ensure that 
L<Marpa::UrHTML> will make its best effort to find an HTML
structure in any document.
Cruft tokens are tokens which even L<Marpa::UrHTML>'s liberal
parsing standards cannot work into a reasonable HTML-like
structure.
In determining the structure of an HTML document,
L<Marpa::UrHTML> ignores cruft much as it was a
comment.

L<Marpa::UrHTML>'s replaces
L<HTML::Parser> text tokens
with one of its three text tokens:
B<WHITESPACE>, B<CDATA> and B<PCDATA>.
WHITESPACE is any text token composed entirely of whitespace
as defined in the HTML 4.01 specification
(L<http://www.w3.org/TR/html4/struct/text.html#h-9.1>).
In the high-level parse,
C<WHITESPACE> is acceptable in some places
where other text is not, so 
L<Marpa::UrHTML>'s needs to distinguish it.
A CDATA token is any non-WHITESPACE text token
returned by L<HTML::Parser>
with a true C<is_cdata> attribute.
All other text tokens are PCDATA.

=head2 Handler Declarations


L<Marpa::UrHTML>'s initially receives its input as tokens
from L<HTML::Parser>.
The following
L<Marpa::UrHTML>'s pseudo-classes allow handlers to be assigned
to deal with certain
L<HTML::Parser> tokens as they come in:
C<:COMMENT>,
C<:PCDATA>
C<:PI>
and C<:CRUFT>.
These pseudo-classes assign handlers for comments,
PCDATA, SGML processing instructions, and cruft tokens, respectively.

   Supply pseudo-class examples.

The "top" handler is always the last to be called in any parse.
The "top" of the parse deals with a non-element -- the entire
physical document, including
the prolog, the trailer and the html element.
The default top handler takes the literal values of all of its
children and returns them as text.
It is very often useful for the user
to assign their own top handler.
The user can do this with the
C<:TOP> pseudo-class.

If a handler is specified for a tagname, it is called
whenever that element is found,
regardless of whether it has an explicit start
tag or an explicit end tag.
Elements that might be recognized by L<Marpa::UrHTML>
even when there are no explicit tags for them are 
C<html>,
C<head>,
C<body>,
C<table>,
C<tbody>,
C<tr>,
and C<td>.
L<Marpa::UrHTML> is even more liberal in placing virtual end tags.
At the end of they physical file, for example,
L<Marpa::UrHTML> will create a virtual end tag for any element
which remains open.

On the other hand, any misplaced
start tag or end tags which end up being classified
as cruft will not cause the handler for that tagname
to be called.

A consequence of the these rules and the structure of
HTML is that in every parse,
the handler for the C<html>, C<head>, and <body> elements
will be called once and only once.
For example, in the following HTML,

     <title>Title</title><p>some text<head>

a handler for the head element will be called just once,
with "C<< <title>Title</title><p>some text<head> >>"
as its contents.
The misplaced "C<< <head> >>" start tag will be classified
as cruft.
It will be part of the original contents for a C<html>
and a C<body> handler, but
will not be in contents of any call to a handler for
a C<head> element.

In L<Marpa::UrHTML> handler specifiers,
elements and class names should be all alphanumerics, hyphens
and underscores.
Other characters are reserved for future syntax extensions.
If you need class or tag names with other characters,
you should use the hash form of handler specification,
where arbitrary characters can be put into either a class
or element name, with one restriction:
L<Marpa::UrHTML> currently restricts itself to L<HTML::Parser>'s
default handling of element tag names.
This follows the HTML standards (but B<not> the XML standards)
and treats tag names as case insensitive.

For elements, multiple specifiers can match.
When they do,
More narrowly targeted specifiers take precedence over less
narrowly targeted ones, with class taking precedence over tag name.
This means that a handler specifier for a specific tagname and
class takes precedence over one which is just for the class.
A handler specifier only specifying the class will take precedence
over one specifying only the tagname.
And a handler specifiying only the tagname takes precedence over
the wildcard handler for all elements.

For example, suppose a L<Marpa::UrHTML> object, is created as follows

    $urhtml = Marpa::UrHTML->new(
        {   handlers => [ q{*} => \&wildcard_handler ],
            [ 'div'        => \&div_handler ],
            [ '.class1'    => \&class1_handler ],
            [ 'div.class1' => \&div_class1_handler ]
        }
    );

handlers would be assigned as in this table.

    Element   Class       Handler
    'span'    'class1'    class1_handler1
    'span'    'class2'    wildcard_handler1
    'div'     'class1'    div_class1_handler1
    'div'     'class2'    div_handler1

    Actually write code for the above and create a test case.

=head2 How to Write I<Marpa::UrHTML> Actions

=head3 The Tree Method: It doesn't Fit HTML Very Well

The typical method of evaluating high-level parses
is to view the parse structure as an upside down
tree, with the root node at the top and the leaf nodes
at the bottom.
Leaf nodes have no children, but all others do.
The root node has no parent, but all the others do.

In the tree method the actions are assigned to nodes.
The actions are called recursively.
The result of each action becomes one of the arguments
to its parent node.
The result of the root node is the value of the whole parse.

What's the problem?  Consider this HTML fragment, an C<< <p> >> element:

     <p> I am&nbsp;text<br>
     </p><strong>more &nbsp;text </strong><br>
     Even&nbsp;more text<br>
     Yet more text
     </p>

From the point of view of a handler for the C<< <p> >> element,
how many children are there?
In the tradtional method, one part of the answer seems easy.
The C<< <strong> >> element should be a single child.
But even that is dubious.  The handler may be interested in a series
of text characters.
That the text characters are inside a 
C<< <strong> >> element may be useful information, but
the handler may want to conveniently subject both to the same kind
of processing?

And how should the non-element text be dealt with?
Is it two tokens?
Should an effort be made to keep consecutive stretches of text
in a single child.
By default, L<HTML::Parser> does not do so.
What about the whitespace?
And does the C< &amp;nbsp; > markup count as whitespace?

There is no one answer to questions like these that works
for all actions.
Evaluating HTML parses requires
an evaluation method more flexible than
the tree method.
Evaluating HTML parses requires
a method where the tree method is just one point of view.

=head3 The Domain Method

L<Marpa::UrHTML>'s actions have a domain.
The Domain API allows points of view to be taken of this domain.
Each domain corresponds to one or more consective characters of text in
the original document, and that is one point of view
-- the B<original text> point of view.

Domains are never zero-length, and they never overlap.
But a domain can contained another domain.
The containing domain is the B<parent domain>,
and the contained domain is a B<subdomain>
or B<child domain>.

A subdomain which has an action which returns a defined value
is an B<evaluated subdomain>.
The B<literal text> point of view is the same as the B<original text>
point of view, except where it contains an evaluated subdomain it replaces
the characters of the original text with the stringified value of that subdomain.
This means, for example, that actions which return a zero-length string have
the effect of deleting their domain from the literal text.

    After here -- left over from previous drafts

L<Marpa::UrHTML>'s actions get their data from calls to
the L<Marpa::UrHTML> API.
Each L<Marpa::UrHTML> object
also makes available to its handlers
a special variable for
data special to that object:
C<$Marpa::UrHTML::INSTANCE>.
C<$Marpa::UrHTML::INSTANCE> is initialized to
an empty hash.
Otherwise, what is done with it is completely up
to the user.
For example, where programming via side effects
is more natural that passing data up the parse
tree, 
C<$Marpa::UrHTML::INSTANCE> can be used to
store the data,
and the handler for the C<:TOP> pseudoclass
can return it as the value of the parse.

     Mention an example of this technique.

=head3 Nodes and Children

Actions can be called on elements and non-elements.
Collectively these are the B<nodes> of parse.

To keep the API model simple, 
L<Marpa::UrHTML> makes it appear to all actions
as if their nodes had at least one child node.
Even the actions for the token pseudoclasses,
like C<:PCDATA>,
appear to have a single child node -- the token.

=head3 Literal and Original Contents

The children of an action may be either B<evaluated>
or B<unevaluated>.
A child is evaluated if another handler 
was called on it and that 
other handler returned something other
than undef.
In any other case, the child is unevaluated.

=head3 The Action API: Simple Utilities

The C<descendant_data> API call, discussed below,
is the Swiss Army knife of the L<Marpa::UrHTML>
API, but much work can be done using 
the simpler utilites described in this section.

=over

=item C<attributes>

Returns a hash ref to the attributes of the start token.
This hash ref is exactly the hash ref returned
for the C<attr> arg specification of L<HTML::Parser>.
The C<attributes> API call
returns an empty hash
if there were no attributes,
if there was no start token for this element,
or if this handler is being called on a non-element.

=item C<descendant_values>

The C<descendant_values> call is for those cases where
only children with values are of interest.
It returns a pointer to an array of those values.
No elements of this array will be undefined --
children which did not have values are simply ignored.

=item C<contents>

For an element, returns its literal contents.
For an non-element, returns undef.

=item C<end_tag>

For an element with an explicit end tag,
returns the original text of the end tag.
Otherwise, returns undef.

=item C<literal>

Returns a string containing the literal contents
of the element or non-element.

=item C<literal_ref>

Returns a string containing a reference
to the literal contents
of the element or non-element.

=item C<offset>

=item C<original>

=item C<start_tag>

For an element with an explicit start tag,
returns the original text of the start tag.
Otherwise, returns undef.

=item C<tagname>

=item C<title>

=back

=head4 The C<descendant_data> API call.

    Marpa::UrHTML::descendant_data('value,literal');

=over

=item C<element>

=item C<value>

=item C<literal>

=item C<original>

=item C<pseudoclass>

=item C<token_type>

=back

=head2 How L<Marpa::UrHMTL> looks at HTML

    Put this section later.

Every SGML/HTML document contains an SGML prolog, an B<root element>,
and an SGML trailer.  The SGML prologs and trailer can be zero length.
The root element consists of an optional start tag C<< <html> >>,
an optional end tag C<< </html> >>,
and the text and markup between the two tags, called the "contents".
The root element is not optional, but
its contents may be zero length.

In the contents of the root element can be other elements.
Every element has a B<tagname>.
The root element has the tagname "C<html>".

Start tags and end tags may be missing.
This is legal for the root element, and several others,
as specified in the standards (for example,
L<http://www.w3.org/TR/html4/>).
L<Marpa::UrHTML> tolerates missing end tags, and some missing start tags,
even when this is forbidden by the
standards.
B<Missing tags> are also called B<implicit> or B<virtual tags>.
An tag which is not missing is an B<explicit tag>.

The contents of HTML elements,
in addition to other HTML elements,
can include B<non-elements>.
The trailer and prolog will be entirely non-elements.
HTML elements can contain both elements and non-elements.
In the following HTML fragment

    <p>I say<q>hello</q>I don't know why you say<q>goodbye</q></p>

the C<p> element contains two child elements,
both C<q> elements.  It also contains two stretches of non-element
text, both of which begin with the word "C<I>" and end with the word
"C<say>".

=head1 EXPORTS

L<Marpa::UrHTML> exports nothing by default.
Optionally, L<Marpa::UrHTML::urhtml> may be exported.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2009 Jeffrey Kegler, all rights reserved.

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl 5.10.0.
