=head1 NAME

Marpa::UrHTML - High-level HTML Parser

=head1 SYNOPSIS

    use Marpa::UrHTML;
    my $p1 = Marpa::UrHTML->new($urhtml_args);
    print Marpa::UrHTML->new($urhtml_args)->parse( \$document );
    my $p = Marpa::UrHTML->new( { handlers => \@handlers, } );

=head1 DESCRIPTION

L<Marpa::UrHTML> does "high-level" parsing of HTML.
Low-level HTML parsing is converting an HTML document into a series of tokens.
High-level HTML parsing is determining the overall structure of the document.
L<Marpa::UrHTML> allows the user to specify handlers to be called on the various
elements and non-elements of an HTML document.

=head2 How L<Marpa::UrHMTL> looks at HTML

L<Marpa::UrHTML> is an extremely liberal HTML parser.
L<Marpa::UrHTML> will treat any document as HTML, if perhaps
invalid or broken HTML, and parse accordingly.

Every SGML/HTML document contains an SGML prolog, an C<html> element,
and an SGML trailer.  The SGML prologs and trailer can be zero length.
The C<html> element consists of a start tag C<< <html> >>,
an end tag C<< </html> >>
and the text between them, called the "contents".
in which case they are also said to be "virtual" tags.
The contents of the C<html> element may be zero length.

In the contents of the C<html> element can be other elements.
Capitalization is significant here,
The "C<html> element" is not the same as an "HTML element".
The B<html element> is the top-level element in any HTML document,
and will be unique in a valid document.
Contained in the C<html> element can be many B<HTML elements>.

Every element has a B<tagname>.
In a valid HTML document,
only the C<html> element will have the tagname "C<html>".

Start tags and end tags may be missing.
This is legal for the many HTML elements,
including the C<html> element itself.
B<Missing tags> are also called B<implicit> or B<virtual tags>.
An tag which is not missing is an B<explicit tag>.

The contents of HTML elements,
in addition to other HTML elements,
can include B<non-elements>.
The trailer and prolog will be entirely non-elements.
HTML elements can contain both elements and non-elements.
In the following HTML fragment

    <p>I say<q>hello</q>I don't know why you say<q>goodbye</q></p>

the C<p> element contains two child elements,
both C<q> elements.  It also contains two stretches of non-element
text, both of which begin with the word "C<I>" and end with the word
"C<say>".

L<Marpa::UrHTML>'s uses L<HTML::Parser> to do its low-level parsing,
or tokenization.
L<HTML::Parser> returns six kinds of token.
B<start tag tokens> and B<end tag tokens> (or "start tokens"
and "end tokens") are always part of elements.
The non-element tokens are text, processing instructions, SGML declarations
and comments.

For liberal high-level parsing, L<Marpa::UrHTML> introduces a token type of its
own: cruft.
Cruft tokens are tokens which even L<Marpa::UrHTML>'s liberal
parsing standards cannot work into a reasonable HTML-like
structure.
L<Marpa::UrHTML> ignores cruft in determining the structure of
an HTML document, much as it the cruft were comments.

Text tokens can be of two types: CDATA and PCDATA.
A PCDATA token is any text token
returned by L<HTML::Parser>
with a false C<is_cdata> attribute.

=head1 METHODS

=over

=item new

    my $urhtml = Marpa::UrHTML->new($urhtml_args);

The C<new> method returns a new L<Marpa::UrHTML> document.
Its optional arguments are referencess to hashes of named arguments.
Handlers and other options may be specified,
L<as described below|//"Options>.

     What happens if no args?  A copy?

=item parse

    print $urhtml->parse( \$document );

The C<parse> method takes a reference to a string as its only,
required,
argument.
This string will be treated as HTML and parsed.
L<Marpa::UrHTML> objects are good for one parse only --
for a new parse, a
new L<Marpa::UrHTML> object should be created.

=back

=head2 Options to the C<new> method

=over

=item C<handlers>

The most important L<Marpa::UrHTML> option is the handlers option.
It is a reference to an array of handler declarations.
The handler declaration may either be short form (references to arrays of two elements)
or long form (hash refs).

=item C<trace_conflicts>

A boolean which turns on tracing of parse conflicts.
These should not be of interest to the average user.

=item C<trace_terminals>

A boolean which turns on tracing of terminals.

=item C<trace_fh>

A file handle.  Warning and diagnostics are printed to C<trace_fh>.

=back

=head2 Handler Declarations (Short Form)

Handler specs can be either array pointers (short form),
or hash pointers (long form).
The short, array form is the usual form.
The long, hash form can be useful for dealing when
element or class names with unusual characters.

A short (or array) form handler spec is a pointer to
an array of two elements.
The first is a string containing
a CSS-style specification.
The second element is the handler closure.
Here's an example:

    Marpa::UrHTML->new( { handlers => [ 'spacer' => \&delete_spacers ] } );

In this example, the specifier is C<spacer>.
When the specifier is a lowercase bareword,
it's taken as a tag name.
The C<spacer> specification indicates
that the closure should be called on all elements with the C<spacer> tagname.
The above code tells L<Marpa::UrHTML> to delete all C<spacer> elements.
(C<spacer> was a tag to add white space supported by
older versions of the Netscape browser.)

The handler specifications follow CSS B<style>, because it is handy
and likely to be familiar to the user.
The syntax is outlined in detail below, but
the following two rules sum it up:

    Use lowercase except for syntax special to L<Marpa::UrHTML>.
    Simple things work, irrelevant and complicated things don't.

HTML class names can also be in specifiers.  For example

    [ '.zipcode' => \&normalize_zipcode } ]

indicates that the C<normalize_zipcode> subroutine is the handler for
all elements whose class is zipcode.

A dotted pair of lowercase names specifies a handler that applies only
to elements with a specific tag name and class name.
For example,

    [ 'span.zipcode' => \&normalize_zipcode ]

indicates that C<normalize_zipcode> is the handler
for C<span> elements whose class attribute is "C<zipcode>".

As a special case, a handler specifier consisting of just an asterisk
is a wildcard matching all elements.

    [ q{*} => \&normalize_whitespace ]

L<Marpa::UrHTML> pseudo specifiers use the same syntax
except that lowercase is reserved for CSS pseudo-classes,
none of which 
L<Marpa::UrHTML> supports as of this version.
L<Marpa::UrHTML>'s pseudo-classes must always be specified in upper-case.

L<Marpa::UrHTML>'s initially receives its input as tokens
from L<HTML::Parser>.
The following
L<Marpa::UrHTML>'s pseudo-classes allow handlers to be assigned
to deal with certain
L<HTML::Parser> tokens as they come in:
C<:COMMENT>,
C<:PCDATA>
C<:PI>
and C<:CRUFT>.
These pseudo-classes assign handlers for comments,
PCDATA, SGML processing instructions, and cruft tokens, respectively.

   Supply pseudo-class examples.

The "top" handler is always the last to be called in any parse.
The "top" of the parse deals with a non-element -- the entire
physical document, including
the prolog, the trailer and the html element.
The default top handler takes the literal values of all of its
children and returns them as text.
It is very often useful for the user
to assign their own top handler.
The user can do this with the
C<:TOP> pseudo-class.

If a handler is specified for a tagname, it is called
whenever that element is found,
regardless of whether it has an explicit start
tag or an explicit end tag.
Elements that might be recognized by L<Marpa::UrHTML>
even when there are no explicit tags for them are 
C<html>,
C<head>,
C<body>,
C<table>,
C<tbody>,
C<tr>,
and C<td>.
L<Marpa::UrHTML> is even more liberal in placing virtual end tags.
At the end of they physical file, for example,
L<Marpa::UrHTML> will create a virtual end tag for any element
which remains open.

On the other hand, any misplaced
start tag or end tags which end up being classified
as cruft will not cause the handler for that tagname
to be called.

A consequence of the these rules and the structure of
HTML is that in every parse,
the handler for the C<html>, C<head>, and <body> elements
will be called once and only once.
For example, in the following HTML,

     <title>Title</title><p>some text<head>

a handler for the head element will be called just once,
with "C<< <title>Title</title><p>some text<head> >>"
as its contents.
The misplaced "C<< <head> >>" start tag will be classified
as cruft.
It will be part of the original contents for a C<html>
and a C<body> handler, but
will not be in contents of any call to a handler for
a C<head> element.

In L<Marpa::UrHTML> handler specifiers,
elements and class names should be all alphanumerics, hyphens
and underscores.
Other characters are reserved for future syntax extensions.
If you need class or tag names with other characters,
you should use the hash form of handler specification,
where arbitrary characters can be put into either a class
or element name, with one restriction:
L<Marpa::UrHTML> currently restricts itself to L<HTML::Parser>'s
default handling of element tag names.
This follows the HTML standards (but B<not> the XML standards)
and treats tag names as case insensitive.

For elements, multiple specifiers can match.
When they do,
More narrowly targeted specifiers take precedence over less
narrowly targeted ones, with class taking precedence over tag name.
This means that a handler specifier for a specific tagname and
class takes precedence over one which is just for the class.
A handler specifier only specifying the class will take precedence
over one specifying only the tagname.
And a handler specifiying only the tagname takes precedence over
the wildcard handler for all elements.

For example, suppose a L<Marpa::UrHTML> object, is created as follows

    $urhtml = Marpa::UrHTML->new(
        {   handlers => [ q{*} => \&wildcard_handler ],
            [ 'div'        => \&div_handler ],
            [ '.class1'    => \&class1_handler ],
            [ 'div.class1' => \&div_class1_handler ]
        }
    );

handlers would be assigned as in this table.

    Element   Class       Handler
    'span'    'class1'    class1_handler1
    'span'    'class2'    wildcard_handler1
    'div'     'class1'    div_class1_handler1
    'div'     'class2'    div_handler1

    Actually write code for the above and create a test case.

     Casing:
     HTML elements NOT case-sensitive.
     XML elements case-sensitive.
     class names case-sensitive.
     CSS pseudo-classes NOT case-sensitive.

=head2 Handler Declarations (Long Form)

The action specifiers do not accept the CSS syntax escaping of characters.
Whatever merits would be alleged for this, it would be very awkward when combined with
Perl's own string escapes.
In the specifiers, all characters except alphanumerics, hyphen and underscore are
reserved for future extensions.

For elements and classnames with arbitrary names, or for any purpose
where it is convenient, there is a "long form"
for handler declarations.
The long form is a hash reference with these named args:

    element
    class
    pseudoclass
    action

Here's an example of a L<Marpa::UrHTML> object being created with
handlers declarations in the long form:

     Add example here.

=head2 How to Write I<Marpa::UrHTML> Handlers

=head3 Handler Utilities

=over

=item C<Marpa::UrHTML::child_data>

    Marpa::UrHTML::child_data('value,literal');

=item C<Marpa::UrHTML::child_values()>

=item C<$Marpa::UrHTML::INSTANCE>

=item C<Marpa::UrHTML::title()>

=item C<Marpa::UrHTML::attributes()>

=item C<Marpa::UrHTML::literal()>

=item C<Marpa::UrHTML::literal_ref()>

=item C<Marpa::UrHTML::original()>

=item C<Marpa::UrHTML::tagname()>

=back

=head4 The C<child_data> Argspec

=over

=item C<element>

=item C<value>

=item C<literal>

=item C<original>

=item C<pseudoclass>

=item C<token_type>

=back

=head1 AUTHOR

Jeffrey Kegler

=head1 BUGS

Please report any bugs or feature requests to
C<bug-marpa at rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Marpa>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

=begin Marpa::Test::Display:

## skip display

=end Marpa::Test::Display:

    perldoc Marpa
    
You can also look for information at:

=over 4

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Marpa>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Marpa>

=item * RT: CPAN's request tracker

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Marpa>

=item * Search CPAN

L<http://search.cpan.org/dist/Marpa>

=back

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2009 Jeffrey Kegler, all rights reserved.

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl 5.10.0.
