=head1 NAME

Marpa::UrHTML - High-level HTML Parser

=head1 SYNOPSIS

Delete all tables:

=for Marpa::Display
name: 'UrHTML Synopsis: Delete Tables'
perltidy: '-dcsc -sil=0'

    use Marpa::UrHTML qw(urhtml);

    my $with_table = 'Text<table><tr><td>I am a cell</table> More Text';
    my $no_table   = urhtml( \$with_table, { table => sub { return q{} } });

=for Marpa::Display::End

Delete everything B<but> tables:

=for Marpa::Display
name: 'UrHTML Synopsis: Delete Everything But Tables'
perltidy: '-dcsc -sil=0'

    my %handlers_to_keep_only_tables = (
        table  => sub { return Marpa::UrHTML::original() },
        ':TOP' => sub { return \( join q{}, @{ Marpa::UrHTML::values() } ) }
    );
    my $only_table = urhtml( \$with_table, \%handlers_to_keep_only_tables );

=for Marpa::Display::End

The same logic works even if a table is very defective:

=for Marpa::Display
name: 'UrHTML Synopsis: Defective Tables'
perltidy: '-dcsc -sil=0'

    my $with_bad_table = 'Text<tr>I am a cell</table> More Text';
    my $only_bad_table =
        urhtml( \$with_bad_table, \%handlers_to_keep_only_tables );

=for Marpa::Display::End

Delete all comments:

=for Marpa::Display
name: 'UrHTML Synopsis: Delete Comments'
perltidy: '-dcsc -sil=0'

    my $with_comment = 'Text <!-- I am a comment --> I am not a comment';
    my $no_comment   = urhtml( \$with_comment,
        { ':COMMENT' => sub { return q{} } });

=for Marpa::Display::End

Change the title:

=for Marpa::Display
name: 'UrHTML Synopsis: Change Title'
perltidy: '-dcsc -sil=0'

    my $old_title = '<title>Old Title</title>A little html text';
    my $new_title = urhtml(
        \$old_title,
        {   'title' => sub { return '<title>New Title</title>' }
        }
    );

=for Marpa::Display::End

Delete all elements with a class attribute
of "C<delete_me>":

=for Marpa::Display
name: 'UrHTML Synopsis: Delete by Class'
perltidy: '-dcsc -sil=0'

    my $stuff_to_be_edited = '<p>A<p class="delete_me">B<p>C';
    my $edited_stuff       = urhtml( \$stuff_to_be_edited,
        { '.delete_me' => sub { return q{} } });

=for Marpa::Display::End

L<Marpa::UrHTML> recognizes elements even if they have missing
start and/or end tags.
Since it knows about missing tags, it can supply them:

=for Marpa::Display
name: 'UrHTML Synopsis: Supply Missing Tags'
perltidy: '-dcsc -sil=0'

    sub supply_missing_tags {
        my $tagname = Marpa::UrHTML::tagname();
        return if $empty_elements{$tagname};
        return ( Marpa::UrHTML::start_tag() // "<$tagname>\n" )
            . Marpa::UrHTML::contents() .
            ( Marpa::UrHTML::end_tag() // "</$tagname>\n" );
    }
    my $html_with_just_a_title = '<title>I am a title and That is IT!';
    my $valid_html_with_all_tags =
        urhtml( \$html_with_just_a_title, { q{*} => \&supply_missing_tags } );

=for Marpa::Display::End

L<Marpa::UrHTML> understands the hierarchical structure of HTML elements,
and calls its handlers recursively.
Finding the maximum nesting depth of the elements is straightforward:

=for Marpa::Display
name: 'UrHTML Synopsis: Maximum Element Depth'
perltidy: '-dcsc -sil=0'

    sub depth_below_me {
        return List::Util::max( 0, @{ Marpa::UrHTML::values() } );
    }
    my %handlers_to_calculate_maximum_element_depth = (
        q{*}   => sub { return 1 + depth_below_me() },
        ':TOP' => sub { return depth_below_me() },
    );
    my $maximum_depth_with_just_a_title = urhtml( \$html_with_just_a_title,
        \%handlers_to_calculate_maximum_element_depth );

=for Marpa::Display::End

Since L<Marpa::UrHTML> tracks actual elements, however tagged, the maximum
depth in elements is the same for C<$valid_html_with_all_tags>
and C<$html_with_just_a_title>.

=head1 DESCRIPTION

L<Marpa::UrHTML> does "high-level" parsing of HTML.
It allows handlers to be specified for elements, tokens and other
components in the hierarchical structure of an HMTL document.
L<Marpa::UrHTML> is an extremely liberal HTML parser.
L<Marpa::UrHTML> does not reject any documents,
no mater how poorly they fit the HTML standards.
L<Marpa::UrHTML> will work with any document,
parsing according to
as reasonable an HTML parse structure as it can find.

=head1 THE C<urhtml> STATIC METHOD

There is only one, static, method in L<Marpa::UrHMTL>:
C<Marpa::UrHMTL::urhtml>.S<  >
C<urhtml> takes one or more arguments.
The first argument is required, and must be a pointer to
a string to be parsed as HTML.
The second and
subsequent arguments (all optional) are hash references
with handler descriptions.
(See L<the synopsis|//"SYNOPSIS"> for several examples of
calls using the C<urhtml> method.)

=head2 CSS-style Handler Options

Handler descriptions in L<Marpa::UrHTML> are key-value pairs
in a hash.
In each pair, the key is a CSS-style handler specifier,
and the value is a closure,
which is called the B<action> for the
handler.

Specifiers are "CSS-style" in their syntax copies some of the most basic cases
of CSS specifiers.
No attempt is planned
to implement the full CSS specifier syntax,
much of which is irrelevant.

Supported specifier syntaxes are as follows:

=over

=item Tagname Specifiers

        table  => sub { return Marpa::UrHTML::original() },

If a specifier contains no special characters ("special"
meaning
anything except alphanumerics, hyphens and underscores, it is taken
as the name of an element.
Consistent with L<HTML::Parser>'s default behavior,
element names must be specified in lowercase.

=item Class Specifiers

A specifier which begins with a dot or period (such as "C<.delete_me>")
will match any element whose class attribute is 
"C<delete_me>".

=item Tagname-Class Pair Specifiers

A specifier which contains a dot or period somewhere other than
the first position (such as "C<span.label>")
is treated as a dotted tagname-class pair.
Its action will be called for
any component whose tagname and class attribute both match.

=item The Tagname Wildcard Specifier

A specifier of just an asterisk ("C<*>") matches all elements.
Be careful to note that matching all elements is B<not> the same
as matching all components.
The element wildcard specifier will not match any pseudoclasses.

=item Pseudoclass Specifiers

    ':COMMENT' => \&delete_it

A specifier which begins with a colon ("C<:>") is a pseudoclass.
L<Marpa::UrHTML> defines
pseudoclasses to deal with tokens and other non-element
components of the HTML hierarchy.

=back

=head3 Conflicting Specifiers

Only one handler is called for each component.
An element component may match several specifiers.
An element component can match handlers specified by tagname,
specified by class,
and specified by tagname-class pair.
In addition, every element matches the wildcard specifier.

Where an element component matches several specifiers,
the action is picked based on the B<most specific match>,
with class being consider more specific than tagname.
Here's the order from most specific to least specific:

    Matches by tagname-class pair
    Matches by class
    Matches by tagname
    The wildcard match

Here's an example:

=for Marpa::Display
name: 'UrHTML Pod: Handler Precedence'
perltidy: '-dcsc -sil=0'

    my $html = <<'END_OF_HTML';
    <span class="high">High Span</span>
    <span class="low">Low Span</span>
    <div class="high">High Div</div>
    <div class="low">Low Div</div>
    <div class="oddball">Oddball Div</div>
    END_OF_HTML

    my $result = Marpa::UrHTML::urhtml(
        \$html,
        {   q{*} => sub {
                return "wildcard handler: " . Marpa::UrHTML::contents();
            },
            'head' => sub { return Marpa::UrHTML::literal() },
            'html' => sub { return Marpa::UrHTML::literal() },
            'body' => sub { return Marpa::UrHTML::literal() },
            'div'  => sub {
                return '"div" handler: ' . Marpa::UrHTML::contents();
            },
            '.high' => sub {
                return '".high" handler: ' . Marpa::UrHTML::contents();
            },
            'div.high' => sub {
                return '"div.high" handler: ' . Marpa::UrHTML::contents();
            },
            '.oddball' => sub {
                return '".oddball" handler: ' . Marpa::UrHTML::contents();
            },
        }
    );

=for Marpa::Display::End

=for Marpa::Display
name: 'UrHTML Pod: Handler Precedence Result'
normalize-whitespace: 1

    ".high" handler: High Span
    wildcard handler: Low Span
    "div.high" handler: High Div
    "div" handler: Low Div
    ".oddball" handler: Oddball Div

=for Marpa::Display::End

=head3 Actual Structure vs. Element Tags

In a defective HTML document, tags for an element may be missing.
Also, tags for an element may exist
that did not fit into
the structure of an HTML document,
even by
L<HTML::Parser>'s very liberal standards.
Where structure and tagging conflict,
L<HTML::Parser> follows structure.
Following the structure means, for example,
that handlers for the C<html>, C<head>,
and C<body> elements will be called once and only once for every
document.

For example, consider this short and very defective HTML document:

=for Marpa::Display
name: 'UrHTML Pod: Structure vs. Element Example'
normalize-whitespace: 1

    <title>Short</title><p>Text</head><head>

=for Marpa::Display::End

The document starts with an untagged header,
then has start and end tags in its body,
in reverse order.
L<HTML::Parser>'s is very liberal in its parsing,
but the two C<head> tags cannot fit into any reasonable parse
structure.
If an action is specified for the C<head> element,
it will be called for actual header,
when consists of the text "C<< <title>Short</title> >>".
The action for the C<head> element will not be called again,
and the two stray tags, C<< </head> >> and C<< <head> >>,
will be treated as "cruft" tokens in the C<body> element.
(More on L<cruft|//"Cruft"> below.)

=head3 Details of the Specifier Syntax

For elements and class names only alphanumerics, hyphens and underscores are supported.
Elements must be specified in lowercase, but they will match tagnames in the original
document on a case-insensitive basis.

Forcing element names to be lowercase follows the default behavior of
L<HTML::Parser>, which coerces all tagnames to lowercase.
This is consistent with the HTML standards.
It is B<not> consistent with the XML standards,
and an option to configure this behavior may be added in
the future.

Pseudoclass names special to
L<Marpa::UrHTML> are case-sensitive, and must be all uppercase.
Lowercase is reserved for CSS pseudoclasses.
The CSS standard specifies that its pseudoclass names are case-indifferent.
It does not at present seem useful to support any CSS pseudoclasses.

=head1 PSEUDOCLASSES

L<Marpa::UrHTML> uses
L<HTML::Parser> to do its low-level parsing.
L<Marpa::UrHTML>'s parsing therefore begins
where L<HTML::Parser> leaves off.
L<HTML::Parser>'s "events".
become the tokens for L<Marpa::UrHTML>'s parser.

Besides tokens and elements,
three other HTML components are of interest,
and have corresponding pseudoclasses:
the physical document's SGML prolog (C<:PROLOG>),
the physical document's SGML trailer (C<:TRAILER>),
and the HTML document as a whole (C<:TOP>).

=head2 :CDATA

The C<:CDATA> pseudoclass specifies the action for
CDATA tokens.
Its action is called once for each non-whitespace raw C<text> event.
(Raw text is text in which any markup and entities should be left as is.)

More precisely,
a C<:CDATA> token is created from any
L<HTML::Parser> C<text> event that has the C<is_cdata> flag on,
and that contains a non-whitespace character as
as defined in the HTML 4.01 specification
(L<http://www.w3.org/TR/html4/struct/text.html#h-9.1>).
L<Marpa::UrHTML> has separate tokens because
the distinction between C<:PCDATA> and C<:CDATA>
is often important.
It is also avoids trying to track a C<is_cdata> flag
as text, values and tokens are created, reassembled and destroyed.

=head2 :COMMENT

The C<:COMMENT> pseudoclass specifies the action for HTML comments.
Its action is called once for every C<HTML::Parser> C<comment> event that
is not reclassed as cruft.

=head2 :CRUFT

The C<:COMMENT> pseudoclass specifies the action for cruft.
Its action is called once for every C<HTML::Parser> event that
L<Marpa::UrHTML> reclasses as cruft.

L<Marpa::UrHTML> reclasses tokens as cruft when
they do not fit the structure of an HTML document.
One example of a token 
L<Marpa::UrHTML> would reclass as cruft is a
stray C<< </head> >> end tag in the HTML body.

Reclassing tokens as cruft is only done as the last resort.
L<HTML::Parser> prefers to forgive
violations of the HTML standards when it can.

Cruft is preserved in the original text view.
It is treated in much the same way as comments.

=head2 :DECL

The C<:DECL> pseudoclass specifies the action for SGML declarations.
Its action is called once for every C<HTML::Parser> C<declaration> event that
is not reclassed as cruft.

=head2 :PCDATA

The C<:PCDATA> pseudoclass specifies the action for
PCDATA tokens.
Its action is called once for each non-whitespace non-raw C<text> event.

More precisely,
a C<:PCDATA> token is created from any
L<HTML::Parser> C<text> event that has the C<is_cdata> flag B<off>,
and that contains a non-whitespace character as
as defined in the HTML 4.01 specification
(L<http://www.w3.org/TR/html4/struct/text.html#h-9.1>).

Markup and entities
C<:PCDATA> text
are expected to be intrepreted eventually,
but it can be counter-productive to do this
during parsing.
For example an user may be rewriting a document for display on the web,
and may need to leave markup and entities exactly as they are for the client browser's
rendering to interpret.

To allow flexibility,
L<Marpa::UrHTML> leaves interpretation of markup and entities entirely to
the user.
A user who does choose to do the interpretation herself
may do it in the actions,
or deal with it in post-processing.
CPAN has excellent tools for this,
some of which are part of L<HTML::Parser>.

=head2 :PI

The C<:PI> pseudoclass specifies the action for SGML processing instructions.
Its action is called once for every L<HTML::Parser> C<process> event that
is not reclassed as cruft.

=head2 :PROLOG

The C<:PROLOG> pseudoclass specifies the action for SGML prolog.
This is the part of the HTML document which precedes the HTML root element.
Components valid in the
prolog include SGML comments, processing instructions and whitespace.

=head2 :TOP

The action specified for the C<:TOP> pseudoclass will be called
one and only once in every parse,
and will be the last action called in every parse.
The C<:TOP> component is the the entire
physical document, including
the SGML prolog,
the root element,
and the SGML trailer.
All the other HTML components in a document
will be descendants of the C<:TOP> component.

The C<:TOP> action is unique, in that there is always an action
for it, even if one is not specified.
The default C<:TOP> action returns a reference to a string
with the literal text value of all
of its descendants.

=head3 Root Element vs. TOP Component

It is important to distinguish the C<:TOP>
component from the root element.
The root element is the HTML element whose tagname is "C<html>", though
its start and end tags are optional
and can be omitted even in strictly valid HTML.
The root element is always present
The C<:TOP> component is a non-element, so it never has tags.
Tags for the root element are optional.

The distinction is that the root element is a descendant of the C<:TOP>
component, and not vice versa.
Also, the SGML prolog and SGML trailer are descendants of the C<:TOP>
component and they are never descendants of the root element.
The C<:TOP> action will be called once and only once in every parse.

If an action for the root element is specified it will also be called
once and only once in every parse.
An action for the root element can be specified in same way as actions
for other elements, by using its tagname of "C<html>".
Any element wildcard action also applies to the root element.

=head2 :TRAILER

The C<:TRAILER> pseudoclass specifies the action for SGML trailer.
This is the part of the HTML document which precedes the HTML root element.
Components valid in the
prolog include SGML comments, processing instructions, and whitespace.
Cruft can also be found here, though for L<Marpa::UrHTML> that is an
last resort.

=head2 :WHITESPACE

A L<Marpa::UrHTML> token is created for every
L<HTML::Parser> C<text> event which is entirely whitespace
as defined in the HTML 4.01 specification
(L<http://www.w3.org/TR/html4/struct/text.html#h-9.1>).
To do high-level parsing,
L<Marpa::UrHTML> needs to
distinguishes whitespace text from other text.
Whitespace is acceptable in places where non-whitespace is not,
and the difference can be very significant structurally.

=head1 VIEWS

I hope L<the synopsis|//"SYNOPSIS"> persuades the reader
that the semantics of L<Marpa::UrHTML> are natural.
This naturalness is achieved at the price of some novelty.
Some readers may want to skip this section and go straight to
the API.
Other will prefer to have the background of this section
first.

This section (and for that matter, this whole document)
treats the components of an HTML document as a hierarchy,
with the TOP component on top, and the tokens on the bottom.
L<Marpa::UrHTML>'s processing model does not force
each handlers to know precise what children it will have
or even how many there will be.
Given the nature of HTML, this would not be reasonable.

L<Marpa::UrHTML>'s semantics place little emphasis on what
a components direct children are.
It focuses instead on descendants.
The terms ancestor and descendant are used in the standard way:
A component is
an B<ancestor> of a second component if it is above that second
component in the hierarchy.
In this case, also,
the second component is a B<descendant> of the first one.

=head2 The Original View

The original view sees the text of the component as it was
originally passed to the parser.
The original view never changes.

=head2 The Token View

The token view sees the tokens for that component.
As described above L<Marpa::UrHTML>, using
L<HTML::Parser>, produces a token stream.
The token view sees the tokens corresponding to the
original text of a component.
The token view never changes.

=head2 The Values View

When actions are called, they return a value.
If that value is defined, it becomes part of the B<values view> of
its ancestors.
The values view sees the values produced by the actions for
the descendants of a component.
The values view is an array, with the values ordered according to the
lexical order of the component whose action returned them.
If no handlers return defined values, the values view remains empty,
that is, it will always be a zero-length array.

The values view is hierarchical.  If a component's action returns a
defined value, it makes all the values for any of its descendants
invisible.
A value returned by a component "replaces" all descendant values.
(These "invisible" values of those descendants are in fact lost forever,
unless a copy of them or a pointer has been preserved somewhere.)

As a special case, if an action for a component returns a Perl C<undef>,
not only do the values of all its descendants become invisible,
that component itself also becomes invisible to the values view.
By returning C<undef>, a handler "drops out" of the values view.

=head2 The Literal View

The literal view can be thought of as a mix between the original view
and the values view.
It sees a text string, like the original view.
But unlike the original view, the literal view changes when values are
visibile.

Where values are visible, the literal view sees them in stringized form.
For descendants without visible values, the literal view is the same as the original
view.

The literal view sees all its descendants, whether stringized values or original
text, in the original lexical order.
This is true of all L<Marpa::UrHTML>'s views:
everything is seen in the original lexical order.

=head2 The Descendants View

Just as the literal view can be thought of as a mix between the original view
and the values view,
the descendants view can be thought of a mix between the token view and the
values view.

The descendants view sees a series of the component's descendants,
in lexical order.
Where a value is visible, the descendants view sees the component with the
visible value.
Where no value is visible, the descendants view sees tokens.

The descendants view is not a textual view.  It sees Perl data for each of the
descendants.  It is implemented via the L<//"Marpa::UrHTML::descendants"> method,
which allows the most detailed view of any of the action API calls.

=head3 The Values View and the Traditional Tree Semantics

For those used to the the traditional tree processing semantics,
the values view resembles it, but with a major difference.
The traditional semantics of hierarhical processing assumed
a well-defined tree, with all nodes computing values from
their immediate children.

The values view allows pieces of the tree to come into
and fall out of its sight.
The values view takes into account only visible descendants.
This allows the values view to be mixed with other views.

The values view is the closest thing L<Marpa::UrHTML> has to
the traditional semantics for high-level parsing: that of a
trees of nodes, the value of each is computed from its
immediate children.  The major difference
is that
the values view does not assign values to all components,
only to those with handlers that returned a defined value.

The traditional model required the parse to 
exactly how many children
each node had, and to stick to that model for all
semantic processing.
The values view also sees a fixed number of children
at each point, but it does not force this to be the model
for all the semantic processing.

=head2 Views and Efficiency

Views are more efficient than the traditional tree processing
semantics, because values do not need
to be computed for components which are not of interest.

=head1 ACTIONS

=head3 Nodes and Children

=head3 The Action API: Simple Utilities

The C<descendants> API call, discussed below,
is the Swiss Army knife of the L<Marpa::UrHTML>
API, but much work can be done using 
the simpler utilites described in this section.

=over

=item C<attributes>

Returns a hash ref to the attributes of the start token.
This hash ref is exactly the hash ref returned
for the C<attr> arg specification of L<HTML::Parser>.
The C<attributes> API call
returns an empty hash
if there were no attributes,
if there was no start token for this element,
or if this handler is being called on a non-element.

=item C<values>

The C<values> call is for those cases where
only children with values are of interest.
It returns a pointer to an array of those values.
No elements of this array will be undefined --
children which did not have values are simply ignored.

=item C<contents>

For an element, returns its literal contents.
For an non-element, returns undef.

=item C<end_tag>

For an element with an explicit end tag,
returns the original text of the end tag.
Otherwise, returns undef.

=item C<literal>

Returns a string containing the literal contents
of the element or non-element.

=item C<literal_ref>

Returns a string containing a reference
to the literal contents
of the element or non-element.

=item C<offset>

=item C<original>

=item C<start_tag>

For an element with an explicit start tag,
returns the original text of the start tag.
Otherwise, returns undef.

=item C<tagname>

=item C<title>

=back

=head4 The C<descendants> API call.

    Marpa::UrHTML::descendants('value,literal');

=over

=item C<element>

=item C<value>

=item C<literal>

=item C<original>

=item C<pseudoclass>

=item C<token_type>

=back

=head1 THE INSTANCE HASH

L<Marpa::UrHTML>'s actions get their data from calls to
the L<Marpa::UrHTML> API.
Each L<Marpa::UrHTML> object
also makes available to its handlers
a special variable for
data special to that object:
C<$Marpa::UrHTML::INSTANCE>.
C<$Marpa::UrHTML::INSTANCE> is initialized to
an empty hash.
Otherwise, what is done with it is completely up
to the user.
For example, where programming via side effects
is more natural that passing data up the parse
tree, 
C<$Marpa::UrHTML::INSTANCE> can be used to
store the data,
and the handler for the C<:TOP> pseudoclass
can return it as the value of the parse.

=head1 EXPLICIT AND IMPLICIT ELEMENTS

If a handler is specified for a tagname, it is called
whenever that element is found,
regardless of whether it has an explicit start
tag or an explicit end tag.
Elements that might be recognized by L<Marpa::UrHTML>
even when there are no explicit tags for them are 
C<html>,
C<head>,
C<body>,
C<table>,
C<tbody>,
C<tr>,
and C<td>.
L<Marpa::UrHTML> is even more liberal in placing virtual end tags.
At the end of they physical file, for example,
L<Marpa::UrHTML> will create a virtual end tag for any element
which remains open.

=head1 EXPORTS

L<Marpa::UrHTML> exports nothing by default.
Optionally, L<Marpa::UrHTML::urhtml> may be exported.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2009 Jeffrey Kegler, all rights reserved.

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl 5.10.0.
