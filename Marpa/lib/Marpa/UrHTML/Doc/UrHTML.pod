=head1 NAME

Marpa::UrHTML - High-level HTML Parser

=head1 SYNOPSIS

Delete all tables:

=for Marpa::Display
name: 'UrHTML Synopsis: Delete Tables'
perltidy: '-dcsc -sil=0'

    use Marpa::UrHTML qw(urhtml);

    my $with_table = 'Text<table><tr><td>I am a cell</table> More Text';
    my $no_table   = urhtml( \$with_table, { table => sub { return q{} } });

=for Marpa::Display::End

Delete everything B<but> tables:

=for Marpa::Display
name: 'UrHTML Synopsis: Delete Everything But Tables'
perltidy: '-dcsc -sil=0'

    my %handlers_to_keep_only_tables = (
        table  => sub { return Marpa::UrHTML::original() },
        ':TOP' => sub { return \( join q{}, @{ Marpa::UrHTML::values() } ) }
    );
    my $only_table = urhtml( \$with_table, \%handlers_to_keep_only_tables );

=for Marpa::Display::End

The same logic works even if a table is very defective:

=for Marpa::Display
name: 'UrHTML Synopsis: Defective Tables'
perltidy: '-dcsc -sil=0'

    my $with_bad_table = 'Text<tr>I am a cell</table> More Text';
    my $only_bad_table =
        urhtml( \$with_bad_table, \%handlers_to_keep_only_tables );

=for Marpa::Display::End

Delete all comments:

=for Marpa::Display
name: 'UrHTML Synopsis: Delete Comments'
perltidy: '-dcsc -sil=0'

    my $with_comment = 'Text <!-- I am a comment --> I am not a comment';
    my $no_comment   = urhtml( \$with_comment,
        { ':COMMENT' => sub { return q{} } });

=for Marpa::Display::End

Change the title:

=for Marpa::Display
name: 'UrHTML Synopsis: Change Title'
perltidy: '-dcsc -sil=0'

    my $old_title = '<title>Old Title</title>A little html text';
    my $new_title = urhtml(
        \$old_title,
        {   'title' => sub { return '<title>New Title</title>' }
        }
    );

=for Marpa::Display::End

Delete all elements with a class attribute
of "C<delete_me>":

=for Marpa::Display
name: 'UrHTML Synopsis: Delete by Class'
perltidy: '-dcsc -sil=0'

    my $stuff_to_be_edited = '<p>A<p class="delete_me">B<p>C';
    my $edited_stuff       = urhtml( \$stuff_to_be_edited,
        { '.delete_me' => sub { return q{} } });

=for Marpa::Display::End

L<Marpa::UrHTML> recognizes elements even if they have missing
start and/or end tags.
Since it knows about missing tags, it can supply them:

=for Marpa::Display
name: 'UrHTML Synopsis: Supply Missing Tags'
perltidy: '-dcsc -sil=0'

    sub supply_missing_tags {
        my $tagname = Marpa::UrHTML::tagname();
        return if $empty_elements{$tagname};
        return ( Marpa::UrHTML::start_tag() // "<$tagname>\n" )
            . Marpa::UrHTML::contents() .
            ( Marpa::UrHTML::end_tag() // "</$tagname>\n" );
    }
    my $html_with_just_a_title = '<title>I am a title and That is IT!';
    my $valid_html_with_all_tags =
        urhtml( \$html_with_just_a_title, { q{*} => \&supply_missing_tags } );

=for Marpa::Display::End

L<Marpa::UrHTML> understands the hierarchical structure of HTML elements,
and calls its handlers recursively.
Finding the maximum nesting depth of the elements is straightforward:

=for Marpa::Display
name: 'UrHTML Synopsis: Maximum Element Depth'
perltidy: '-dcsc -sil=0'

    sub depth_below_me {
        return List::Util::max( 0, @{ Marpa::UrHTML::values() } );
    }
    my %handlers_to_calculate_maximum_element_depth = (
        q{*}   => sub { return 1 + depth_below_me() },
        ':TOP' => sub { return depth_below_me() },
    );
    my $maximum_depth_with_just_a_title = urhtml( \$html_with_just_a_title,
        \%handlers_to_calculate_maximum_element_depth );

=for Marpa::Display::End

Since L<Marpa::UrHTML> tracks actual elements, however tagged, the maximum
depth in elements is the same for C<$valid_html_with_all_tags>
and C<$html_with_just_a_title>.

=head1 DESCRIPTION

L<Marpa::UrHTML> does "high-level" parsing of HTML.
It allows handlers to be specified for elements, tokens and other
components in the hierarchical structure of an HMTL document.
L<Marpa::UrHTML> is an extremely liberal HTML parser.
L<Marpa::UrHTML> does not reject any documents,
no mater how poorly they fit the HTML standards.
L<Marpa::UrHTML> will work with any document,
parsing according to
as reasonable an HTML parse structure as it can find.

=head1 THE C<urhtml> STATIC METHOD

There is only one, static, method in L<Marpa::UrHMTL>:
C<Marpa::UrHMTL::urhtml>.S<  >
C<urhtml> takes one or more arguments.
The first argument is required, and must be a pointer to
a string to be parsed as HTML.
The second and
subsequent arguments (all optional) are hash references
with handler descriptions.
(See L<the synopsis|//"SYNOPSIS"> for several examples of
calls using the C<urhtml> method.)

=head2 CSS-style Handler Options

Handler descriptions in L<Marpa::UrHTML> are key-value pairs
in a hash.
In each pair, the key is a CSS-style handler specifier,
and the value is a closure,
which is called the B<action> for the
handler.

Specifiers are "CSS-style" in their syntax copies some of the most basic cases
of CSS specifiers.
No attempt is planned
to implement the full CSS specifier syntax,
much of which is irrelevant.

Supported specifier syntaxes are as follows:

=over

=item Tagname Specifiers

        table  => sub { return Marpa::UrHTML::original() },

If a specifier contains no special characters ("special"
meaning
anything except alphanumerics, hyphens and underscores, it is taken
as the name of an element.
Consistent with L<HTML::Parser>'s default behavior,
element names must be specified in lowercase.

=item Class Specifiers

A specifier which begins with a dot or period (such as "C<.delete_me>")
will match any element whose class attribute is 
"C<delete_me>".

=item Tagname-Class Pair Specifiers

A specifier which contains a dot or period somewhere other than
the first position (such as "C<span.label>")
is treated as a dotted tagname-class pair.
Its action will be called for
any component whose tagname and class attribute both match.

=item The Tagname Wildcard Specifier

A specifier of just an asterisk ("C<*>") matches all elements.
Be careful to note that matching all elements is B<not> the same
as matching all components.
The element wildcard specifier will not match any pseudoclasses.

=item Pseudoclass Specifiers

    ':COMMENT' => \&delete_it

A specifier which begins with a colon ("C<:>") is a pseudoclass.
L<Marpa::UrHTML> defines
pseudoclasses to deal with tokens and other non-element
components of the HTML hierarchy.

=back

=head3 Conflicting Specifiers

Only one handler is called for each component.
An element component may match several specifiers.
An element component can match handlers specified by tagname,
specified by class,
and specified by tagname-class pair.
In addition, every element matches the wildcard specifier.

Where an element component matches several specifiers,
the action is picked based on the B<most specific match>,
with class being consider more specific than tagname.
Here's the order from most specific to least specific:

    Matches by tagname-class pair
    Matches by class
    Matches by tagname
    The wildcard match

Here's an example:

=for Marpa::Display
name: 'UrHTML Pod: Handler Precedence'
perltidy: '-dcsc -sil=0'

    my $html = <<'END_OF_HTML';
    <span class="high">High Span</span>
    <span class="low">Low Span</span>
    <div class="high">High Div</div>
    <div class="low">Low Div</div>
    <div class="oddball">Oddball Div</div>
    END_OF_HTML

    my $result = Marpa::UrHTML::urhtml(
        \$html,
        {   q{*} => sub {
                return "wildcard handler: " . Marpa::UrHTML::contents();
            },
            'head' => sub { return Marpa::UrHTML::literal() },
            'html' => sub { return Marpa::UrHTML::literal() },
            'body' => sub { return Marpa::UrHTML::literal() },
            'div'  => sub {
                return '"div" handler: ' . Marpa::UrHTML::contents();
            },
            '.high' => sub {
                return '".high" handler: ' . Marpa::UrHTML::contents();
            },
            'div.high' => sub {
                return '"div.high" handler: ' . Marpa::UrHTML::contents();
            },
            '.oddball' => sub {
                return '".oddball" handler: ' . Marpa::UrHTML::contents();
            },
        }
    );

=for Marpa::Display::End

=for Marpa::Display
name: 'UrHTML Pod: Handler Precedence Result'
normalize-whitespace: 1

    ".high" handler: High Span
    wildcard handler: Low Span
    "div.high" handler: High Div
    "div" handler: Low Div
    ".oddball" handler: Oddball Div

=for Marpa::Display::End

=head3 Actual Structure vs. Element Tags

In a defective HTML document, tags for an element may be missing.
Also, tags for an element may exist
that did not fit into
the structure of an HTML document,
even by
L<HTML::Parser>'s very liberal standards.
Where structure and tagging conflict,
L<HTML::Parser> follows structure.
Following the structure means, for example,
that handlers for the C<html>, C<head>,
and C<body> elements will be called once and only once for every
document.

For example, consider this short and very defective HTML document:

=for Marpa::Display
name: 'UrHTML Pod: Structure vs. Element Example'
normalize-whitespace: 1

    <title>Short</title><p>Text</head><head>

=for Marpa::Display::End

The document starts with an untagged header,
then has start and end tags in its body,
in reverse order.
L<HTML::Parser>'s is very liberal in its parsing,
but the two C<head> tags cannot fit into any reasonable parse
structure.
If an action is specified for the C<head> element,
it will be called for actual header,
when consists of the text "C<< <title>Short</title> >>".
The action for the C<head> element will not be called again,
and the two stray tags, C<< </head> >> and C<< <head> >>,
will be treated as "cruft" tokens in the C<body> element.
(More on L<cruft|//"Cruft"> below.)

=head3 Details of the Specifier Syntax

For elements and class names only alphanumerics, hyphens and underscores are supported.
Elements must be specified in lowercase, but they will match tagnames in the original
document on a case-insensitive basis.

Forcing element names to be lowercase follows the default behavior of
L<HTML::Parser>, which coerces all tagnames to lowercase.
This is consistent with the HTML standards.
It is B<not> consistent with the XML standards,
and an option to configure this behavior may be added in
the future.

Pseudoclass names special to
L<Marpa::UrHTML> are case-sensitive, and must be all uppercase.
Lowercase is reserved for CSS pseudoclasses.
The CSS standard specifies that its pseudoclass names are case-indifferent.
It does not at present seem useful to support any CSS pseudoclasses.

=head1 PSEUDOCLASSES

L<Marpa::UrHTML> uses
L<HTML::Parser> to do its low-level parsing.
L<Marpa::UrHTML>'s parsing therefore begins
where L<HTML::Parser> leaves off.
L<HTML::Parser>'s "events".
become the tokens for L<Marpa::UrHTML>'s parser.

Besides tokens and elements,
three other HTML components are of interest,
and have corresponding pseudoclasses:
the physical document's SGML prolog (C<:PROLOG>),
the physical document's SGML trailer (C<:TRAILER>),
and the HTML document as a whole (C<:TOP>).

=head2 :CDATA

The C<:CDATA> pseudoclass specifies the action for
CDATA tokens.
Its action is called once for each non-whitespace raw C<text> event.
(Raw text is text in which any markup and entities should be left as is.)

More precisely,
a C<:CDATA> token is created from any
L<HTML::Parser> C<text> event that has the C<is_cdata> flag on,
and that contains a non-whitespace character as
as defined in the HTML 4.01 specification
(L<http://www.w3.org/TR/html4/struct/text.html#h-9.1>).
L<Marpa::UrHTML> has separate tokens because
the distinction between C<:PCDATA> and C<:CDATA>
is often important.
It is also avoids trying to track a C<is_cdata> flag
as text, values and tokens are created, reassembled and destroyed.

=head2 :COMMENT

The C<:COMMENT> pseudoclass specifies the action for HTML comments.
Its action is called once for every C<HTML::Parser> C<comment> event that
is not reclassed as cruft.

=head2 :CRUFT

The C<:COMMENT> pseudoclass specifies the action for cruft.
Its action is called once for every C<HTML::Parser> event that
L<Marpa::UrHTML> reclasses as cruft.

L<Marpa::UrHTML> reclasses tokens as cruft when
they do not fit the structure of an HTML document.
One example of a token 
L<Marpa::UrHTML> would reclass as cruft is a
stray C<< </head> >> end tag in the HTML body.

Reclassing tokens as cruft is only done as the last resort.
L<HTML::Parser> prefers to forgive
violations of the HTML standards when it can.

Cruft is preserved in the original text view.
It is treated in much the same way as comments.

=head2 :DECL

The C<:DECL> pseudoclass specifies the action for SGML declarations.
Its action is called once for every C<HTML::Parser> C<declaration> event that
is not reclassed as cruft.

=head2 :PCDATA

The C<:PCDATA> pseudoclass specifies the action for
PCDATA tokens.
Its action is called once for each non-whitespace non-raw C<text> event.

More precisely,
a C<:PCDATA> token is created from any
L<HTML::Parser> C<text> event that has the C<is_cdata> flag B<off>,
and that contains a non-whitespace character as
as defined in the HTML 4.01 specification
(L<http://www.w3.org/TR/html4/struct/text.html#h-9.1>).

Markup and entities
C<:PCDATA> text
are expected to be intrepreted eventually,
but it can be counter-productive to do this
during parsing.
For example an user may be rewriting a document for display on the web,
and may need to leave markup and entities exactly as they are for the client browser's
rendering to interpret.

To allow flexibility,
L<Marpa::UrHTML> leaves interpretation of markup and entities entirely to
the user.
A user who does choose to do the interpretation herself
may do it in the actions,
or deal with it in post-processing.
CPAN has excellent tools for this,
some of which are part of L<HTML::Parser>.

=head2 :PI

The C<:PI> pseudoclass specifies the action for SGML processing instructions.
Its action is called once for every L<HTML::Parser> C<process> event that
is not reclassed as cruft.

=head2 :PROLOG

The C<:PROLOG> pseudoclass specifies the action for SGML prolog.
This is the part of the HTML document which precedes the HTML root element.
Components valid in the
prolog include SGML comments, processing instructions and whitespace.

=head2 :TOP

The action specified for the C<:TOP> pseudoclass will be called
one and only once in every parse,
and will be the last action called in every parse.
The C<:TOP> component is the the entire
physical document, including
the SGML prolog,
the root element,
and the SGML trailer.
All the other HTML components in a document
will be descendants of the C<:TOP> component.

The C<:TOP> action is unique, in that there is always an action
for it, even if one is not specified.
The default C<:TOP> action returns a reference to a string
with the literal text value of all
of its descendants.

=head3 Root Element vs. TOP Component

It is important to distinguish the C<:TOP>
component from the root element.
The root element is the HTML element whose tagname is "C<html>", though
its start and end tags are optional
and can be omitted even in strictly valid HTML.
The root element is always present
The C<:TOP> component is a non-element, so it never has tags.
Tags for the root element are optional.

The distinction is that the root element is a descendant of the C<:TOP>
component, and not vice versa.
Also, the SGML prolog and SGML trailer are descendants of the C<:TOP>
component and they are never descendants of the root element.
The C<:TOP> action will be called once and only once in every parse.

If an action for the root element is specified it will also be called
once and only once in every parse.
An action for the root element can be specified in same way as actions
for other elements, by using its tagname of "C<html>".
Any element wildcard action also applies to the root element.

=head2 :TRAILER

The C<:TRAILER> pseudoclass specifies the action for SGML trailer.
This is the part of the HTML document which precedes the HTML root element.
Components valid in the
prolog include SGML comments, processing instructions, and whitespace.
Cruft can also be found here, though for L<Marpa::UrHTML> that is an
last resort.

=head2 :WHITESPACE

A L<Marpa::UrHTML> token is created for every
L<HTML::Parser> C<text> event which is entirely whitespace
as defined in the HTML 4.01 specification
(L<http://www.w3.org/TR/html4/struct/text.html#h-9.1>).
To do high-level parsing,
L<Marpa::UrHTML> needs to
distinguishes whitespace text from other text.
Whitespace is acceptable in places where non-whitespace is not,
and the difference can be very significant structurally.

=head1 HOW TO WRITE ACTIONS

=head2 Handler Declarations

If a handler is specified for a tagname, it is called
whenever that element is found,
regardless of whether it has an explicit start
tag or an explicit end tag.
Elements that might be recognized by L<Marpa::UrHTML>
even when there are no explicit tags for them are 
C<html>,
C<head>,
C<body>,
C<table>,
C<tbody>,
C<tr>,
and C<td>.
L<Marpa::UrHTML> is even more liberal in placing virtual end tags.
At the end of they physical file, for example,
L<Marpa::UrHTML> will create a virtual end tag for any element
which remains open.

=head1 ACTIONS

=head1 INCLUDE?

=head2 The Tree Method: It doesn't Fit HTML Very Well

The typical method of evaluating high-level parses
is to view the parse structure as an upside down
tree, with the root node at the top and the leaf nodes
at the bottom.
Leaf nodes have no children, but all others do.
The root node has no parent, but all the others do.

In the tree method the actions are assigned to nodes.
The actions are called recursively.
The result of each action becomes one of the arguments
to its parent node.
The result of the root node is the value of the whole parse.

What's the problem?  Consider this HTML fragment, an C<< <p> >> element:

     <p> I am&nbsp;text<br>
     </p><strong>more &nbsp;text </strong><br>
     Even&nbsp;more text<br>
     Yet more text
     </p>

From the point of view of a handler for the C<< <p> >> element,
how many children are there?
In the tradtional method, one part of the answer seems easy.
The C<< <strong> >> element should be a single child.
But even that is dubious.  The handler may be interested in a series
of text characters.
That the text characters are inside a 
C<< <strong> >> element may be useful information, but
the handler may want to conveniently subject both to the same kind
of processing?

And how should the non-element text be dealt with?
Is it two tokens?
Should an effort be made to keep consecutive stretches of text
in a single child.
By default, L<HTML::Parser> does not do so.
What about the whitespace?
And does the C< &amp;nbsp; > markup count as whitespace?

There is no one answer to questions like these that works
for all actions.
Evaluating HTML parses requires
an evaluation method more flexible than
the tree method.
Evaluating HTML parses requires
a method where the tree method is just one point of view.

=head3 The Domain Method

L<Marpa::UrHTML>'s actions have a domain.
The Domain API allows points of view to be taken of this domain.
Each domain corresponds to one or more consective characters of text in
the original document, and that is one point of view
-- the B<original text> point of view.

Domains are never zero-length, and they never overlap.
But a domain can contained another domain.
The containing domain is the B<parent domain>,
and the contained domain is a B<subdomain>
or B<child domain>.

A subdomain which has an action which returns a defined value
is an B<evaluated subdomain>.
The B<literal text> point of view is the same as the B<original text>
point of view, except where it contains an evaluated subdomain it replaces
the characters of the original text with the stringified value of that subdomain.
This means, for example, that actions which return a zero-length string have
the effect of deleting their domain from the literal text.

    After here -- left over from previous drafts

L<Marpa::UrHTML>'s actions get their data from calls to
the L<Marpa::UrHTML> API.
Each L<Marpa::UrHTML> object
also makes available to its handlers
a special variable for
data special to that object:
C<$Marpa::UrHTML::INSTANCE>.
C<$Marpa::UrHTML::INSTANCE> is initialized to
an empty hash.
Otherwise, what is done with it is completely up
to the user.
For example, where programming via side effects
is more natural that passing data up the parse
tree, 
C<$Marpa::UrHTML::INSTANCE> can be used to
store the data,
and the handler for the C<:TOP> pseudoclass
can return it as the value of the parse.

     Mention an example of this technique.

=head3 Nodes and Children

Actions can be called on elements and non-elements.
Collectively these are the B<nodes> of parse.

To keep the API model simple, 
L<Marpa::UrHTML> makes it appear to all actions
as if their nodes had at least one child node.
Even the actions for the token pseudoclasses,
like C<:PCDATA>,
appear to have a single child node -- the token.

=head3 Literal and Original Contents

The children of an action may be either B<evaluated>
or B<unevaluated>.
A child is evaluated if another handler 
was called on it and that 
other handler returned something other
than undef.
In any other case, the child is unevaluated.

=head3 The Action API: Simple Utilities

The C<descendant_data> API call, discussed below,
is the Swiss Army knife of the L<Marpa::UrHTML>
API, but much work can be done using 
the simpler utilites described in this section.

=over

=item C<attributes>

Returns a hash ref to the attributes of the start token.
This hash ref is exactly the hash ref returned
for the C<attr> arg specification of L<HTML::Parser>.
The C<attributes> API call
returns an empty hash
if there were no attributes,
if there was no start token for this element,
or if this handler is being called on a non-element.

=item C<values>

The C<values> call is for those cases where
only children with values are of interest.
It returns a pointer to an array of those values.
No elements of this array will be undefined --
children which did not have values are simply ignored.

=item C<contents>

For an element, returns its literal contents.
For an non-element, returns undef.

=item C<end_tag>

For an element with an explicit end tag,
returns the original text of the end tag.
Otherwise, returns undef.

=item C<literal>

Returns a string containing the literal contents
of the element or non-element.

=item C<literal_ref>

Returns a string containing a reference
to the literal contents
of the element or non-element.

=item C<offset>

=item C<original>

=item C<start_tag>

For an element with an explicit start tag,
returns the original text of the start tag.
Otherwise, returns undef.

=item C<tagname>

=item C<title>

=back

=head4 The C<descendant_data> API call.

    Marpa::UrHTML::descendant_data('value,literal');

=over

=item C<element>

=item C<value>

=item C<literal>

=item C<original>

=item C<pseudoclass>

=item C<token_type>

=back

=head2 How L<Marpa::UrHMTL> looks at HTML

    Put this section later.

Every SGML/HTML document contains an SGML prolog, an B<root element>,
and an SGML trailer.  The SGML prologs and trailer can be zero length.
The root element consists of an optional start tag C<< <html> >>,
an optional end tag C<< </html> >>,
and the text and markup between the two tags, called the "contents".
The root element is not optional, but
its contents may be zero length.

In the contents of the root element can be other elements.
Every element has a B<tagname>.
The root element has the tagname "C<html>".

Start tags and end tags may be missing.
This is legal for the root element, and several others,
as specified in the standards (for example,
L<http://www.w3.org/TR/html4/>).
L<Marpa::UrHTML> tolerates missing end tags, and some missing start tags,
even when this is forbidden by the
standards.
B<Missing tags> are also called B<implicit> or B<virtual tags>.
An tag which is not missing is an B<explicit tag>.

The contents of HTML elements,
in addition to other HTML elements,
can include B<non-elements>.
The trailer and prolog will be entirely non-elements.
HTML elements can contain both elements and non-elements.
In the following HTML fragment

    <p>I say<q>hello</q>I don't know why you say<q>goodbye</q></p>

the C<p> element contains two child elements,
both C<q> elements.  It also contains two stretches of non-element
text, both of which begin with the word "C<I>" and end with the word
"C<say>".

=head1 EXPORTS

L<Marpa::UrHTML> exports nothing by default.
Optionally, L<Marpa::UrHTML::urhtml> may be exported.

=head1 LICENSE AND COPYRIGHT

Copyright 2007-2009 Jeffrey Kegler, all rights reserved.

This program is free software; you can redistribute
it and/or modify it under the same terms as Perl 5.10.0.
