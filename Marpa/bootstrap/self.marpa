semantics are perl5.  version is 0.001_019.  the start symbol is
grammar.

the default lex prefix is qr/(?:[ \t]*(?:\n|(?:\#[^\n]*\n)))*[ \t]*/xms.

grammar: paragraphs, trailing matter.  'grammar'.

paragraphs: empty line separated paragraph sequence.  'concatenate_lines'.

comment: NOT USED: paragraph: empty paragraph.

paragraph: definition paragraph.  'concatenate_lines'.

paragraph: production paragraph.  'concatenate_lines'.

paragraph: terminal paragraph.  'concatenate_lines'.

[ comment paragraph: comment sequence.  'concatenate_lines'. ]

definition paragraph: definition sequence. 'concatenate_lines'.

production paragraph:
    non structural production sentences,
    production sentence,
    non structural production sentences,
    optional action sentence,
    non structural production sentences.
    'production_paragraph'.

non structural production sentences:
optional non structural production sentence sequence.
'concatenate_lines'.

non structural production sentence: /priority/, integer, period.
'non_structural_production_sentence'.

action sentence:
optional /the/, /action/, /is/, action specifier, period.
'long_action_sentence'.

action sentence: action specifier, period.
'short_action_sentence'.

action specifier: string specifier.  'concatenate_lines'.

non-structural production sentence: comment sentence.  'concatenate_lines'.

non-structural terminal sentence: comment sentence.  'concatenate_lines'.

definition: predefined setting, period.  'definition_of_predefined'.  priority 1000.

definition: comment sentence.

definition: bracketed comment.

definition: string definition.  'concatenate_lines'.

predefined setting: default action setting.  'concatenate_lines'.

predefined setting: default null value setting.  'concatenate_lines'.

predefined setting: preamble setting.  'concatenate_lines'.

predefined setting: lex preamble setting.  'concatenate_lines'.

predefined setting: semantics setting.  'concatenate_lines'.

predefined setting: version setting.  'concatenate_lines'.

predefined setting: start symbol setting.  'concatenate_lines'.

predefined setting: default lex prefix setting.  'concatenate_lines'.

semantics setting:  optional /the/, /semantics/, copula, /perl5/.
'semantics_predicate'.

semantics setting: /perl5/, copula, optional /the/, /semantics/.
'semantics_subject'.

version setting: optional /the/, /version/, copula, version number.
'version_predicate'.

version setting: /version number/, copula, optional /the/, /version/.
'version_subject'.

start symbol setting: optional /the/, /start/, /symbol/, copula,
symbol phrase.
'start_symbol_predicate'.

start symbol setting: symbol phrase, copula, optional /the/, /start/,
/symbol/, .
'start_symbol_subject'.

default lex prefix setting: regex, copula, optional /the/, /default/,
/lex/, /prefix/, .
'default_lex_prefix_subject'.

default lex prefix setting: optional /the/, /default/, /lex/,
/prefix/, copula, regex, .
'default_lex_prefix_predicate'.

default null value setting: string specifier, copula, optional /the/, /default/,
/null/, /value/, .
'default_null_value_subject'.

default null value setting: optional /the/, /default/, /null/,
/value/, copula, string specifier, .
'default_null_value_predicate'.

preamble setting: /a/, /preamble/, /is/, string specifier.
priority 1000.
'preamble_predicate'.
 
preamble setting: string specifier, /is/, /a/, /preamble/ .
priority 1000.
'preamble_subject'.
 
lex preamble setting: /a/, /lex/, /preamble/, /is/, string specifier.
priority 1000.
'lex_preamble_predicate'.
 
preamble setting: string specifier, /is/, /a/, /lex/, /preamble/ .
priority 1000.
'lex_preamble_subject'.
 
copula: /is/.

copula: /are/.

string definition:
symbol phrase, /is/, string specifier, period.
'string_definition'.

default action setting:
action specifier, /is/, optional /the/, /default/, /action/.
'default_action_subject'.

default action setting:
optional /the/, /default/, /action/, /is/, action specifier.
'default_action_predicate'.

comment sentence: comment tag, /:/, comment words, period.

comment words: comment word sequence.

literal string: q string.
'q_string'.

literal string: double quoted string.  'concatenate_lines'.

literal string: single quoted string.  'concatenate_lines'.

production sentence: lhs, production copula, rhs, period.
'production_sentence'.

production copula: /:/.

production copula: /::=/.

symbol phrase: symbol word sequence.
'symbol_phrase'.

lhs: symbol phrase.
'lhs'.

rhs: .
'empty_rhs'.

rhs: comma separated rhs element sequence.
'comma_separated_rhs'.

rhs: symbol phrase, /sequence/.
'sequence_rhs'.
priority 1000.

rhs: /optional/, symbol phrase, /sequence/.
priority 2000.
'optional_sequence_rhs'.

rhs: symbol phrase, /separated/, symbol phrase, /sequence/.
priority 2000.
'separated_sequence_rhs'.

rhs: /optional/, symbol phrase, /separated/, symbol phrase, /sequence/.
priority 3000.
'optional_separated_sequence_rhs'.

rhs element: mandatory rhs element.  'concatenate_lines'.

rhs element: Optional rhs element. priority 1000. 'concatenate_lines'.

mandatory rhs element: rhs symbol specifier.
'mandatory_rhs_element'.

optional rhs element: /optional/, rhs symbol specifier.
'optional_rhs_element'.

rhs symbol specifier: symbol phrase.
'rhs_symbol_phrase_specifier'.

rhs symbol specifier: regex.
'rhs_regex_specifier'.

terminal paragraph: non structural terminal sentences, terminal
sentence, non structural terminal sentences.  'concatenate_lines'.

non structural terminal sentences: optional non structural terminal sentence
sequence.  'concatenate_lines'.

terminal sentence:
symbol phrase, /matches/, regex, period.
'regex_terminal_sentence'.

terminal sentence:
/match/, symbol phrase, /using/, string specifier, period.
'string_terminal_sentence'.

string specifier: literal string.  'concatenate_lines'.

string specifier: symbol phrase.
'string_name_specifier'.

match q string using 'lex_q_quote'.

match regex using 'lex_regex'.

empty line matches qr/^\h*\n/xms.

# Some hackery here: The lex prefix will take care of most
# trailing whitespace, but since it is a *PREFIX*, in some
# cases it needs something to look for.  So I provide for
# a single final whitespace, or a single final comment, and
# let the lex prefix do the rest.
#
# A Marpa terminal is not allowed if it matches the null
# string, and that causes some of the complexity here.
trailing matter: final comment.

trailing matter: final whitespace.

trailing matter: .

# a final comment in the document, without or without a proper
# end of line.
final comment matches qr/\#[^\n]*\Z/xms.

# a final character of whitespace.
final whitespace matches qr/\s\z/xms.

bracketed comment matches qr/\x{5b}[^\x{5d}]*\x{5d}/xms.

note: change this to use lex_q_quote sometime(?) -- Doing so would
make this file simpler -- Internalizing the closures used by MDL
makes sense from a number of points of view -- It's slightly more
efficient and internalized routines become available to other
high-level grammar interfaces -- But Marpa self-generates and in
that self-generation I like to test user-specified lex actions --
If I internalize them all, I'll lose that test.

match single quoted string using q{
    my $match_start = pos ${$STRING};
    state $prefix_regex = qr/\G'/oxms;
    return unless ${$STRING} =~ /$prefix_regex/gxms;
    state $regex = qr/\G[^'\0134]*('|\0134')/xms;
    MATCH: while (${$STRING} =~ /$regex/gcxms) {
        next MATCH unless defined $1;
        if ($1 eq q{'}) {
            my $end_pos = pos ${$STRING};
            my $match_length = $end_pos - $match_start;
            my $lex_length = $end_pos - $START;
            return (
                substr(${$STRING}, $match_start, $match_length),
                $lex_length
            );
        }
    }
    return;
}.

match double quoted string using q{
    my $match_start = pos $$STRING;
    state $prefix_regex = qr/\G"/o;
    return unless $$STRING =~ /$prefix_regex/g;
    state $regex = qr/\G[^"\0134]*("|\0134")/;
    MATCH: while ($$STRING =~ /$regex/gc) {
        next MATCH unless defined $1;
        if ($1 eq q{"}) {
            my $end_pos = pos $$STRING;
            my $match_length = $end_pos - $match_start;
            my $lex_length = $end_pos - $START;
            return (
                substr($$STRING, $match_start, $match_length),
                $lex_length
            );
        }
    }
    return;
}.

version number matches qr/\d+\.[\d_.]+\d/.

symbol word matches qr/[a-zA-Z_][a-zA-Z0-9_-]*/.

period matches qr/\./.

integer matches qr/\d+/.

# Do I want to allow comments between "to" and "do" ?
comment tag matches qr/(to\s+do|note|comment)/.

# Includes all non-whitespace printable characters except period
comment word matches qr/[\x{21}-\x{2d}\x{2f}-\x{7e}]+/.

comma matches qr/\,/.

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
